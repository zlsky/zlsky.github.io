<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>




  <meta name="keywords" content="api,反射," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> 反射规则 the law of reflection // Three Stone </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Three Stone</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首頁
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          關於
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          歸檔
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              反射规则 the law of reflection
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-10-24
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/golang/">golang</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/10/24/golang/反射规则/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/24/golang/反射规则/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h2 id="类型和接口(type_and_interfaces)">类型和接口(type and interfaces)</h2><p>因为接口是基于类型系统的（type system），所以首先看下一下go的类型</p>
<p>go是静态类型的。每个变量都有一个静态的类型(static type)，也就是说一种类型在编译的时候被声明和确定了(one type known and fixed at complie time)。如果我们定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   i的类型是int，j的类型是MyInt，i和j的类型是不一样的。尽管他们有着相同的底层类型(?)(underlying type)，但是它们是不能在不转换的情况下互相赋值的。</p>
</blockquote>
<p>类型里面一个重要的分类是接口类型(interface types)，它表示一系列的固定方法。一个接口变量可以存储任何实现这个结构的实际变量(? concrete type)。<br>一个出名的例子就是io包里的io.Reader和io.Writer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   任何类型以上面的特征(? with this signature)实现了Read（或者 Writer）方法，就可以说该类型实现了io.Read（或者io.Writer）。</p>
</blockquote>
<p>这就意味着接口io.Read类型的变量可以存放任何有Read方法的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = os.Stdin</span><br><span class="line">r = bufio.NewReader(r)</span><br><span class="line">r = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="comment">// and so on</span></span><br></pre></td></tr></table></figure>
<p>有一点要搞清楚，不管r里面存放的具体值是什么，r的类型一直都是io.Read：go是静态类型的语言，r的静态类型是io.Read。<br>一个关于接口的非常重要的例子就是空接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代表一个空的方法集，可以存放任何数据类型。因为每个类型都有零个或者更多的方法。<br>有人说go的接口是动态类型(dynamically typed)，这是一种误导。他们其实是静态的类型：一个接口类型的变量一直都有同样的静态类型(static type)，虽然在运行的时候存放在接口类型变量里的值可能会变，但是那些值都会是实现过这个接口的。</p>
<p>我们需要严谨对待上面这些概念，因为反射和接口是紧密相连的。</p>
<h2 id="关于接口的说明（the_representation_of_an_interface）">关于接口的说明（the representation of an interface）</h2><p>一个接口类型的变量是成对存储的(stores a pair)：分配给变量的具体值(concrete value)和该值的类型描述(value’s type descriptor)。更准确说，这个值是实现了该接口的底层具体数据(? the underlaying concrete data item)，类型(type)描述表示这个数据的所有类型信息(the type describes the full type of that item)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">"/dev/tty"</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure>
<p>r包含了值对(the pair)，【value,type】，【tty,<em>os.File】。这里要注意类型</em>os.File继承了不止read一个方法。<br>尽管这里的接口类型只提供Read一种方法，但是值(value)里面带有这个关于这个数值的所有信息。这就是为什么我们这么做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>
<p>这里的赋值表达式是一个类型声明(type assertion)。这个所声明里，r中的元素同时也继承了io.Writer，所以我们可以赋值给w。赋值以后，w就会存有值对(pair):【tty，*os.File】。和存放在r中的值对是一样的。接口的静态类型要求接口变量只能使用接口里所定义的方法，尽管接口变量中存放的值(value)可能拥有大量额方法。</p>
<p>继续上面的例子，我们还可以这么做：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br></pre></td></tr></table></figure></p>
<p>这的空接口变量，empty，一样的包含有同上面相同的值对(pair)，【tty，*os.File】。也就是说一个空的接口能存放所有的变量，包含有关于这个变量我们所需要的所有信息。</p>
<blockquote>
<p>   我们这不需要一个类型声明，是因为我们都知道w是符合空接口的。在这个例子里，我们把Read转换成Writer，我们是需要特别的类型声明的，这是因为Writer的方法不是Reader方法的子集。</p>
</blockquote>
<p>注意一个重要的细节，存放在接口变量中的pai存放的类型一直都是【value,concrete type】，而不是【value,interface type】。接口中不保存接口变量。</p>
<h2 id="反射的第一法则[从接口变量到反射对象的反射(reflection_goes_from_interface_value_to_reflection_object)]">反射的第一法则[从接口变量到反射对象的反射(reflection goes from interface value to reflection object)]</h2><p>简单的说，反射只是检查存放在一个接口变量里的类型和值对（type and value pair）的机制。要了解这些，我们需要知道reflect包里的两个类型：Type和Value。这个两个类型提供了访问结构变量里内容的途径，两个函数，reflect.TypeOf和reflect.ValueOf，可以获得从一个接口数据里面获取reflect.Type和reflect.Value。（当然从reflect.Value里面也能很很容易的获得reflect.Type，但是我们现在暂时把Value和Type的概念区分开）</p>
<p>让我们先来看看TypeOf:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">	 fmt.Println(<span class="string">"type:"</span>, reflect.TypeOf(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: type: float64</span></span><br></pre></td></tr></table></figure></p>
<p>你可能会好奇，这里哪有接口？程序里里面我们传递给reflect.TypeOf的x变量时float64，而不是接口啊。但是跟据godoc里显示，reflect.TypeOf的声明里包含有一个空的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeOf returns the reflection Type of the value in the interface&#123;&#125;.</span></span><br><span class="line"><span class="comment">// TypeOf(nil) returns nil.</span></span><br><span class="line"><span class="keyword">func</span> TypeOf(i <span class="keyword">interface</span>&#123;&#125;) Type &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>reflect.TypeOf(x)</code>时，x首先被存放在一个空的接口中，然后被当成参数传递过去。reflect.Typeof拆开（unpacks）这个空的接口，获取类型的信息（type information）。</p>
<p>那么reflect.ValueOf函数自然是用来获取值（value）的（这里我们忽略样板（? boilerplate），先关注可执行的代码）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, reflect.ValueOf(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: value: &lt;float64 Value&gt;</span></span><br></pre></td></tr></table></figure>
<p>reflect.Type和reflect.ValueOf都拥有很多的方法供我们使用。一个非常重要的例子就是Value有一个Type的方法，这个方法可以从refelct.Value中获得Type。另外一个Type和Value都有的方法是Kind，这个方法可以返回一个常量说明（? a constant indicating(底层类型,例如:int,float)），类似：Uint和Float64等等。同时Value里面还有类似Int和Float的函数，能让我们获取其中获取的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">"kind is float64:"</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, v.Float())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	type: float64</span></span><br><span class="line"><span class="comment">//			kind is float64: true</span></span><br><span class="line"><span class="comment">//			value: 3.4</span></span><br></pre></td></tr></table></figure>
<p>这里还有类似SetInt和SetFloat的方法，但是使用这些方法前我们需要了解settability（？）这个是下面第三部分才能谈到的，待会再讨论。</p>
<p>反射库里面有两个属性需要特别指出来。第一，为了让api简单，Value的setter和getter方法都是基于可以用来保存数据的最大数据类型的：比如所有的有符号整形操作都是基于int64的。也就是说，Value的Int方法返回一个int64的数据，而SetInt的方法获取的是一个int64。用实际的例子里说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">uint8</span> = <span class="string">'x'</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())<span class="comment">// uint8.</span></span><br><span class="line">fmt.Println(<span class="string">"kind is uint8: "</span>, v.Kind() == reflect.Uint8) <span class="comment">// true.</span></span><br><span class="line">x = <span class="typename">uint8</span>(v.Uint())<span class="comment">// v.Uint returns a uint64.</span></span><br></pre></td></tr></table></figure>
<p>第二是属性，反射对象的Kind方法描述的是底层类型（underlying type），不是静态类型。如果一个反射对象包含有一个用户自定义类型，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure>
<p>v的Kind方法返回值依旧是reflect.Int，尽管x的静态类型是MyInt而不是int。也就是说，Kind方法不能识别基于int的MyInt类型，尽管Type是可以的。</p>
<h2 id="反射的第二法则[从反射对象到接口变量的反射(reflection_goes_from_reflection_object_to_interface_value)]">反射的第二法则[从反射对象到接口变量的反射(reflection goes from reflection object to interface value)]</h2><p>就像物理世界中的反射，Go中的反射也有自己反转(inverse)。</p>
<p>给我一个reflect.Value，我们就可以通过Interface这个方法重新得到一个接口。实际上，这个方法吧type和value信息打包成一个接口引用，并且返回：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface returns v's value as an interface&#123;&#125;.</span></span><br><span class="line"><span class="keyword">func</span> (v Value) Interface() <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们可以这么说：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y := v.Interface().(<span class="typename">float64</span>) <span class="comment">// y will have type float64.</span></span><br><span class="line">fmt.Println(y)	<span class="comment">//把有对象v所表示的float64的值答应出来了。</span></span><br></pre></td></tr></table></figure>
<p>我们还可以加以改进。fmt.Println，fmt.Printf等等函数的参数都是以一个空的接口变量传递过去的，也就是说就像我们在之前的例子里一样，这个参数在fmt包里被解包（unpacked）了。所以只要给上面的函数直接传递Interface方法的返回值就能正确的输出内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Interface())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   （为什么不直接使用fmt.Println(v)？这是因为v其实是一个reflect.Value；我们需要的是里面保存的确定的值(? concrete value)）。</p>
</blockquote>
<p>既然我们的值的类型是float64，我们甚至可以使用浮点数类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"value is %7.1e\n"</span>, v.Interface())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: 3.4e+00</span></span><br></pre></td></tr></table></figure>
<p>再说一遍，我们不需要把v.Interface的结果类型转换（? type-assert）。这个空的接口值里面包含有具体数据的类型信息，Printf可以从中获取的到。</p>
<p>简单的说，Interface是函数ValueOf的反转，只可惜的是它的结果都是静态类型interface{}</p>
<p>小结：从接口反射到反射变量，然后又反射回来。</p>
<h2 id="反射的第三法则[要想修改一个反射对象，值必须是可设置的(to_modify_a_reflection_object,the_value_must_be_settable)]">反射的第三法则[要想修改一个反射对象，值必须是可设置的(to modify a reflection object,the value must be settable)]</h2><p>第三条法则是很为微妙(subtle)和让人困惑的(confusing)，但是我们从第一法则(principles)来看的话的，也是很容搞懂的。</p>
<p>下面这些代码无法运行，但是值得我们学习：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//output: panic: reflect.Value.SetFloat using unaddressable value</span></span><br></pre></td></tr></table></figure>
<p>会触发panic，产生一段含混不清的提示，其实问题并不是常量7.1无法寻址，是因为v是不可设置的（not settable）。可设置(settableility)是反射Value的一个属性，但不是所有的反射Value都有这个属性。</p>
<p>Value的CanSet方法可以判断Value可不可设置，如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: settability of v: false</span></span><br></pre></td></tr></table></figure>
<p>对一个不可设置（non-settable）的Value使用set就会报错。那么什么是可设置性（settabiliy）？<br>可设置性有点像可寻址(addressability)，但是更加严格，它是表示一个反射对象可不可修改创建这个反射对象原始存储数据(storage)的属性</p>
<p>可设置性取决于反射对象中保存的是不是原始的数据。当我们输入一下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure></p>
<p>我们传递给reflection.ValueOf的是一个x的拷贝，所以作为reflect.ValueOf的参数用来反射对象的接口，其实x的拷贝，而不是x本身。因此如果下面的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>   理论上是允许运行成功的，只是不会去修改x的值，尽管看起来v是由x创建的一样。其实这样操作会更新x的拷贝在内存中的值，而x本身是不会受到影响的。这样的话会显得让人困惑，而且一点用的都没有。所以这种方法就被规定为非法的，可设置属性是不允许这么操作的。</p>
</blockquote>
<p>可能这些看起来有些怪异（bizarre），但其实是很简单的。这其实是一种很常见的情况，只是有个不同的外在而已。想想当我们把x传递给一个函数的时候：<code>f(x)</code><br>因为我们传递给函数的是x的拷贝而不是x的本身，所以我们知道f不能修改x的值。如果我们想f能修改x的值，那么我们就必须给这个函数传递x的的地址了（也就是x的指针）: <code>f(&amp;x)</code></p>
<p>这样看起来就显得很简单很熟悉了，反射也是同样的运作方式的。如果我们也想让反射修改x的话，我们也必须给反射库(reflection library)一个我们想修改的值得指针。</p>
<p>让我们这操作一下试试。首先我们像往常一样初始化x，然后创建一个指向x的反射变量p：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">"type of p:"</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">"settability of p:"</span>, p.CanSet())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	type of p: *float64</span></span><br><span class="line">			settability of p: <span class="constant">false</span></span><br></pre></td></tr></table></figure>
<p>p这个反射是不可设置的，但是p也也不是我想设置的数据，我们要设置的实际是*p。想要得到p所指向的数据，我们使用Value的Elem方法。这个方法可以通过指针间接访问数据，并且保存在反射Value的变量v中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v := p.Elem()</span><br><span class="line">fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	settability of v: true</span></span><br></pre></td></tr></table></figure>
<p>既然v代表的是x，我们终于可以使用v.SetFloat修改x的值了：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br><span class="line">fmt.Println(v.Interface())</span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	7.1</span></span><br><span class="line">			<span class="number">7.1</span></span><br></pre></td></tr></table></figure></p>
<p>尽管反射执行着语言的功能，通过反射中Type和Values可以掩盖住具体的细节，但是可能还是难以去理解。你只需要记住了，Values需要一个数据的地址才能修改反射所代表的数据。</p>
<h2 id="结构体(Structs)">结构体(Structs)</h2><p>在我们之前的例子里，v并不是指针本身，它只是指针的派生而已。这种方法适用于用反射来修改结构体的域(field)。只要我们有这个结构体的体质，我们就能修改这个结构体的域。</p>
<p>这里有一个简单额例子来分析一下一个结构体变量t。因为我们待会要修改这个结构体，所以我们先用结构体的指针创建反射对象。我们用typeOf保存它的类型，用直接的方法（? straightforward method calls）迭代出所有的域【参考反射包获取更多的细节】。注意我们这里导出了结构体域的名字，但是域本身还是reflect.Value对象的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="typename">int</span></span><br><span class="line">    B <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">typeOfT := s.Type()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">    f := s.Field(i)</span><br><span class="line">    fmt.Printf(<span class="string">"%d: %s %s = %v\n"</span>, i,</span><br><span class="line">        typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	0: A int = 23</span></span><br><span class="line">			<span class="number">1</span>: B <span class="typename">string</span> = skidoo</span><br></pre></td></tr></table></figure>
<p>需要注意的是我们这里使用的可设置性（? there’s one more point about settability introduced in passing here）：这里把T的域名（field name）导出来，是因为一个结构体只有导出的域才能设置。</p>
<p>因为s中保存着一个可设置的反射对象，所以我们可以修改结构体的域：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.Field(<span class="number">0</span>).SetInt(<span class="number">77</span>)</span><br><span class="line">s.Field(<span class="number">1</span>).SetString(<span class="string">"Sunset Strip"</span>)</span><br><span class="line">fmt.Println(<span class="string">"t is now"</span>, t)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	is now &#123;77 Sunset Strip&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果你把程序改成s是由t创建的而不是&amp;t，那么在你调用SetInt和SetString时程序就报错，因为此时t的域是不可修改的。</p>
<h2 id="小结（conclusion）">小结（conclusion）</h2><p>反射的规则：</p>
<ol>
<li>由接口到反射变量的反射</li>
<li>由反射对象到接口的反射</li>
<li>要修改一个反射对象，value必须是可设置的</li>
</ol>
<p>一旦说你了解了这些规则，尽管难以理解，但是Go会变的更容易使用。这是一个强大的工具，在使用的时候要注意，不是绝对必要的时候不要使用。</p>
<p>关于反射我们还有很多没有涉及——在channels中的发送和接收、分配内存、使用slice和map、调用方法和函数——但是这篇文章内容已经足够多了。我们会在后面文章里涉及这些内容中的部分。</p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/api/"> #api </a>
          
            <a href="/tags/反射/"> #反射 </a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/10/25/golang/goroutine背后的系统知识/">goroutine背后的系统知识</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/10/14/object-c/uibutton/">UIButton详解</a>
            
          </div>
        </div>
      

      
      
    </div>
  </div>



    
      <div class="comments" id="comments">
        
          <div class="ds-thread" data-thread-key="2014/10/24/golang/反射规则/"
               data-title="反射规则 the law of reflection" data-url="http://blog.zlsky.me/2014/10/24/golang/反射规则/">
          </div>
        
      </div>
    
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="zhulei" />
          <p class="site-author-name">zhulei</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">84</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">56</span>
              <span class="site-state-item-name">標籤</span>
              
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/zlsky" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://twitter.com/zl8522115" target="_blank">Twitter</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/zlsky" target="_blank">Weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/zhu-lei-46-87" target="_blank">ZhiHu</a>
            </span>
            
          
        </div>

        
        

      </div>

      
        <div class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#类型和接口(type_and_interfaces)"><span class="nav-number">1.</span> <span class="nav-text">类型和接口(type and interfaces)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于接口的说明（the_representation_of_an_interface）"><span class="nav-number">2.</span> <span class="nav-text">关于接口的说明（the representation of an interface）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射的第一法则[从接口变量到反射对象的反射(reflection_goes_from_interface_value_to_reflection_object)]"><span class="nav-number">3.</span> <span class="nav-text">反射的第一法则[从接口变量到反射对象的反射(reflection goes from interface value to reflection object)]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射的第二法则[从反射对象到接口变量的反射(reflection_goes_from_reflection_object_to_interface_value)]"><span class="nav-number">4.</span> <span class="nav-text">反射的第二法则[从反射对象到接口变量的反射(reflection goes from reflection object to interface value)]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射的第三法则[要想修改一个反射对象，值必须是可设置的(to_modify_a_reflection_object,the_value_must_be_settable)]"><span class="nav-number">5.</span> <span class="nav-text">反射的第三法则[要想修改一个反射对象，值必须是可设置的(to modify a reflection object,the value must be settable)]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体(Structs)"><span class="nav-number">6.</span> <span class="nav-text">结构体(Structs)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结（conclusion）"><span class="nav-number">7.</span> <span class="nav-text">小结（conclusion）</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </div>
      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2012 - 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">zhulei</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"threestone"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

</body>
</html>
