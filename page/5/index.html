<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>




  <meta name="keywords" content="zhulei,golang,js,php,opengl" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> Three Stone </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Three Stone</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首頁
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          關於
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          歸檔
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/19/self/sdk接入文档/">
                sdk接入文档
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-19
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/19/self/sdk接入文档/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/19/self/sdk接入文档/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="接入sdk">接入sdk</h1><p><img src="/img/sdk接入文档/sdk_01.jpg" alt="加入类库"></p>
<p><img src="/img/sdk接入文档/sdk_02.jpg" alt="添加framework"></p>
<p><img src="/img/sdk接入文档/sdk_03.jpg" alt="增加编译参数"></p>
<p><img src="/img/sdk接入文档/sdk_04.jpg" alt="修改参数"></p>
<p><img src="/img/sdk接入文档/sdk_05.jpg" alt="初始化"></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/16/apple/apple证书详解/">
                apple证书详解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-16
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/object-c/">object-c</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/16/apple/apple证书详解/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/16/apple/apple证书详解/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>刚接触iOS开发的人难免会对苹果的各种证书、配置文件等不甚了解，可能你按照网上的教程一步一步的成功申请了真机调试，但是还是对其中的缘由一知半解。这篇文章就对Certificate、Provisioning Profile等做个总结。</p>
<h1 id="概念介绍">概念介绍</h1><p>如果你拥有一个开发者账户的话，在iOS Dev Center打开Certificates, Indentifiers &amp; Profiles，你就可以看到如下的列表：</p>
<p><img src="/img/apple证书详解/1.png" alt="apple证书"></p>
<p>Profile Portal改版有一段时间了，改版之后的结构比以前更清晰明了，易于理解和管理。</p>
<p>上面的列表就包含了开发、调试和发布iOS应用程序所需的所有内容：Certificates、Identifiers、Devices、Provisioning Profiles。下面将一一解释这几个东东。</p>
<h2 id="Certificate">Certificate</h2><p>证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting的Code Signing Identity中，你可以设置用于为代码签名的证书。 </p>
<p>众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 </p>
<p><img src="/img/apple证书详解/2.png" alt="apple证书"></p>
<p>证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发应用程序（根据证书种类有不同作用），下面是证书的分类信息：（括号内为证书有效期）</p>
<blockquote>
<p>（注：不同类型的开发者账户所能创建的证书种类不同，关于开发者账户的对比和InHouse证书相关的内容，请见我的另一篇文章）</p>
</blockquote>
<ul>
<li>Development<ul>
<li>App Development (1年)：用来开发和真机调试应用程序。</li>
<li>Push Development (1年)：用来调试Apple Push Notification</li>
</ul>
</li>
<li>Production<ul>
<li>In-House and Ad Hoc (3年)：用来发布In-House和AdHoc的应用程序。</li>
<li>App Store ：用来发布提交App Store的应用程序。</li>
<li>MDM CSR</li>
<li>Push Production (1年)：用来在发布版本中使用Apple Push Notification。</li>
<li>Pass Type ID Certificate</li>
<li>Website Push ID Certificate</li>
</ul>
</li>
</ul>
<p>有一些类型的证书我没有使用过，所以也不了解具体的作用。</p>
<h3 id="App_ID">App ID</h3><p>App ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种： </p>
<ul>
<li>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。</li>
<li>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。</li>
</ul>
<p>每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。下面是目前所有可选的服务和相应的配置要求。</p>
<p><img src="/img/apple证书详解/3.png" alt="apple证书"></p>
<p>如果你的App使用上述的任何一种service，就要按照要求去配置。</p>
<h3 id="Device">Device</h3><p>Device最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。</p>
<p>每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。</p>
<p><strong>举例</strong></p>
<ol>
<li><p>假如第一年，你增加了70个设备，同时删除了10个设备，这个时候，虽然你的设备数是60，但是可用的增加测试机的名额却只有30个了。</p>
</li>
<li><p>到了第二年，你续费了开发者身份，在你第一次登陆进去后，你可以看到你的可用设备恢复成 100 – 60 = 40个了。这个时候，你可以选择删除一些设备，例如你又删除了20个设备，这样你的名额数变成60个。之后你增加了一个设备，因为你选择了增加新设备，苹果认为你已经放弃删除设备以恢复设备数的机会，这样，你的名额就固定成59个。以后删除设备都不会增加新名额了，直到你的下一个membership year开始时才又会有这样的机会来删除设备释放名额。</p>
</li>
</ol>
<p>那如果万一我的设备数达到上限，我又急需要增加新设备怎么办呢？</p>
<p>具体做法是访问：<a href="https://developer.apple.com/contact/" target="_blank" rel="external">https://developer.apple.com/contact/</a>，点击 Program Benefits， 然后在新出来的提交界面中将需求填上。之后苹果会发邮件过来告诉你处理结果，可能需要打电话过去和他们沟通一些细节。在沟通完成后，苹果就可以立即帮助你状态修改到“可删除设备来增加测试设备名额”。这样，你就可以选择性的删除一些不需要的设备来释放一些名额了。</p>
<h2 id="Provisioning_Profile">Provisioning Profile</h2><p>一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。</p>
<p>试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。</p>
<p>例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。</p>
<p><img src="/img/apple证书详解/4.png" alt="apple证书"></p>
<p>如上所述，在一台设备上运行应用程序的过程如下：</p>
<p><img src="/img/apple证书详解/5.png" alt="apple证书"></p>
<p>与证书一样，Provisioning Profile也分为Development和Distribution两种：</p>
<blockquote>
<p>（注：前面提到不同账户类型所能创建的证书种类不同，显然Profile文件的种类是和你所能创建的证书种类相关的）</p>
</blockquote>
<ul>
<li>Development (1年)</li>
<li>Distribution (1年)<ul>
<li>In House</li>
<li>Ad Hoc</li>
<li>App Store</li>
</ul>
</li>
</ul>
<p>In House 与Ad Hoc的不同之处在于：In House没有设备数量限制，而Ad Hoc是用来测试用的，Ad Hoc的包只能运行在该账户内已登记的可用设备上，显然是有最多100个设备的数量限制。所以这两种Provisioning Profile文件的区别就在于其中的设备限制不一样而已，而他们所使用的Certificate是相同的。    </p>
<h1 id="开发/发布流程">开发/发布流程</h1><p>了解了上面的概念，再来看开发及发布流程就非常简单了，而且相信你不用看教程也能一步步完成所有的操作了。</p>
<h2 id="开发/真机调试流程">开发/真机调试流程</h2><p>根据上面的介绍，可以知道进行Development主要有以下几个步骤：</p>
<ul>
<li>申请证书</li>
<li>加入设备</li>
<li>生成Provisioning Profile</li>
<li>设置Xcode Code Sign Identifer</li>
</ul>
<p>事实上第三步通常是不需要的，因为我们通常都是用Xcode生成和管理的iOS Team Provisioning Profile来进行开发，因为它非常方便，所以不需要自己手动生成Provisioning Profile。</p>
<p>iOS Team Provisioning Profile是第一次使用Xcode添加设备时，Xcode自动生成的，它包含了Xcode生成的一个Wildcard App ID（*，匹配所有应用程序），账户里面所有的Devices和所有Development Certificates，如下图所示。因此，team中的所有成员都可以使用这个iOS Team Provisioning Profile在team中的所有设备上调试所有的应用程序。并且当有新设备添加进来时，Xcode会更新这个文件。</p>
<p><img src="/img/apple证书详解/6.png" alt="apple证书"></p>
<h2 id="发布流程">发布流程</h2><p>网上有很多关于发布App Store的流程，我就不缀述了，不过根据上面的概念介绍，不管是App Store、In-House还是Ad-Hoc，打包流程都是差不多的，都包括了以下几个关键步骤：</p>
<ul>
<li>创建发布证书</li>
<li>创建App ID</li>
<li>创建对应的Provisioning Profile文件</li>
<li>设备Bundle ID和App ID一致</li>
<li>设置Xcode Code Sign Identifer，选择合适的Profile和证书进行签名，打包</li>
</ul>
<p>以上就是对证书、Provisioning Profile、App ID等的介绍。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/15/object-c/触摸事件/">
                触摸事件处理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-15
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/ios/">ios</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/15/object-c/触摸事件/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/15/object-c/触摸事件/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>iphone/ipad无键盘的设计是为屏幕争取更多的显示空间，大屏幕在观看图片、文字、视频等方面为用户带来了更好的用户体验。而触摸屏幕是iOS设备接受用户输入的主要方式，包括单击、双击、拨动以及多点触摸等，这些操作都会产生触摸事件。</p>
<p>在Cocoa中，代表触摸对象的类是<code>UITouch</code>。当用户触摸屏幕后，就会产生相应的事件，所有相关的UITouch对象都被包装在事件中，被程序交由特定的对象来处理。UITouch对象直接包括触摸的详细信息。</p>
<h2 id="UITouch类中包含5个属性：">UITouch类中包含5个属性：</h2><ol>
<li>window：触摸产生时所处的窗口。由于窗口可能发生变化，当前所在的窗口不一定是最开始的窗口。</li>
<li>view:触摸产生时所处的视图。由于视图可能发生变化，当前视图也不一定时最初的视图。</li>
<li>tapCount：轻击（Tap）操作和鼠标的单击操作类似，tapCount表示短时间内轻击屏幕的次数。因此可以根据tapCount判断单击、双击或更多的轻击。</li>
<li>timestamp：时间戳记录了触摸事件产生或变化时的时间。单位是秒。</li>
<li><p>phase：触摸事件在屏幕上有一个周期，即触摸开始、触摸点移动、触摸结束，还有中途取消。而通过phase可以查看当前触摸事件在一个周期中所处的状态。phase是<code>UITouchPhase</code>类型的，这是一个枚举配型，包含了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITouchPhaseBegan</span>（触摸开始）</span><br><span class="line"><span class="built_in">UITouchPhaseMoved</span>（接触点移动）</span><br><span class="line"><span class="built_in">UITouchPhaseStationary</span>（接触点无移动）</span><br><span class="line"><span class="built_in">UITouchPhaseEnded</span>（触摸结束）</span><br><span class="line"><span class="built_in">UITouchPhaseCancelled</span>（触摸取消）</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="UITouch类中包含如下成员函数：">UITouch类中包含如下成员函数：</h2><ul>
<li><p><code>- (CGPoint)locationInView:(UIView *)view</code>：函数返回一个CGPoint类型的值，表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置。</p>
</li>
<li><p><code>- (CGPoint)previousLocationInView:(UIView *)view</code>：该方法记录了前一个坐标值，函数返回也是一个CGPoint类型的值， 表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置。</p>
</li>
</ul>
<p>当手指接触到屏幕，不管是单点触摸还是多点触摸，事件都会开始，直到用户所有的手指都离开屏幕。期间所有的UITouch对象都被包含在UIEvent事件对象中，由程序分发给处理者。事件记录了这个周期中所有触摸对象状态的变化。</p>
<p>只要屏幕被触摸，系统就会报若干个触摸的信息封装到UIEvent对象中发送给程序，由管理程序UIApplication对象将事件分发。一般来说，事件将被发给主窗口，然后传给第一响应者对象(<code>FirstResponder</code>)处理。</p>
<p>关于响应者的概念，通过以下几点说明：</p>
<ul>
<li><p>响应者对象（Response object）</p>
<p>响应者对象就是可以响应事件并对事件作出处理。在iOS中，存在UIResponder类，它定义了响应者对象的所有方法。UIApplication、UIView等类都继承了UIResponder类，UIWindow和UIKit中的控件因为继承了UIView，所以也间接继承了UIResponder类，这些类的实例都可以当作响应者。</p>
</li>
<li><p>第一响应者（First responder）</p>
<p>当前接受触摸的响应者对象被称为第一响应者，即表示当前该对象正在与用户交互，它是响应者链的开端。</p>
</li>
<li><p>响应者链（Responder chain）</p>
<p>响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者（next responder）。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow对象）再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>
</li>
<li><p>管理事件分发</p>
<p>视图对触摸事件是否需要作处回应可以通过设置视图的<code>userInteractionEnabled</code>属性。默认状态为<code>YES</code>，如果设置为<code>NO</code>，可以阻止视图接收和分发触摸事件。除此之外，当视图被隐藏（<code>setHidden：YES</code>）或者透明（<code>alpha</code>值为0）也不会收事件。不过这个属性只对视图有效，如果想要整个程序都步响应事件，可以调用<code>UIApplication</code>的<code>beginIngnoringInteractionEvents</code>方法来完全停止事件接收和分发。通过<code>endIngnoringInteractionEvents</code>方法来恢复让程序接收和分发事件。</p>
</li>
</ul>
<p>如果要让视图接收多点触摸，需要设置它的<code>multipleTouchEnabled</code>属性为<code>YES</code>，默认状态下这个属性值为<code>NO</code>，即视图默认不接收多点触摸。</p>
<h2 id="如何处理用户的触摸事件">如何处理用户的触摸事件</h2><p>*首先触摸的对象是视图，而视图的类UIView继承了UIRespnder类，但是要对事件作出处理，还需要重写UIResponder类中定义的事件处理函数。根据不通的触摸状态，程序会调用相应的处理函数，这些函数包括以下几个：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当手指接触屏幕时，就会调用touchesBegan:withEvent方法；</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesBegan:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指在屏幕上移时，动就会调用touchesMoved:withEvent方法；</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesMoved:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指离开屏幕时，就会调用touchesEnded:withEvent方法；</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesEnded:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当触摸被取消（比如触摸过程中被来电打断），就会调用touchesCancelled:withEvent方法。</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesCancelled:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<p>而这几个方法被调用时，正好对应了<code>UITouch</code>类中<code>phase</code>属性的4个枚举值。</p>
<p>上面的四个事件方法，在开发过程中并不要求全部实现，可以根据需要重写特定的方法。对于这4个方法，都有两个相同的参数：<code>NSSet</code>类型的<code>touches</code>和<code>UIEvent</code>类型的<code>event</code>。其中touches表示触摸产生的所有<code>UITouch</code>对象，而event表示特定的事件。因为<code>UIEvent</code>包含了整个触摸过程中所有的触摸对象，因此可以调用<code>allTouches</code>方法获取该事件内所有的触摸对象，也可以调用<code>touchesForVIew</code>：或者<code>touchesForWindows</code>：取出特定视图或者窗口上的触摸对象。在这几个事件中，都可以拿到触摸对象，然后根据其位置，状态，时间属性做逻辑处理。</p>
<p>例如:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch =  [touches anyObject];</span><br><span class="line">    <span class="keyword">if</span>(touch<span class="variable">.tapCount</span> == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子说明在触摸手指离开后，根据tapCount点击的次数来设置当前视图的背景色。不管时一个手指还是多个手指，轻击操作都会使每个触摸对象的tapCount加1，由于上面的例子不需要知道具体触摸对象的位置或时间等，因此可以直接调用touches的anyObject方法来获取任意一个触摸对象然后判断其tapCount的值即可。</p>
<p>检测tapCount可以放在touchesBegan也可以touchesEnded，不过一般后者跟准确，因为touchesEnded可以保证所有的手指都已经离开屏幕，这样就不会把轻击动作和按下拖动等动作混淆。</p>
<p>轻击操作很容易引起歧义，比如当用户点了一次之后，并不知道用户是想单击还是只是双击的一部分，或者点了两次之后并不知道用户是想双击还是继续点击。为了解决这个问题，一般可以使用“<strong>延迟调用</strong>”函数。</p>
<p>例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch =  [touches anyObject];</span><br><span class="line">    <span class="keyword">if</span>(touch<span class="variable">.tapCount</span> == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(setBackground:) withObject:[<span class="built_in">UIColor</span> blueColor] afterDelay:<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示在第一次轻击之后，没有直接更改视图的背景属性，而是通过<code>performSelector：withObject：afterDelay</code>：方法设置2秒中后更改。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch =  [touches anyObject];</span><br><span class="line">    <span class="keyword">if</span>(touch<span class="variable">.tapCount</span> == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(setBackground:) object:[<span class="built_in">UIColor</span> redColor]];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双击就是两次单击的组合，因此在第一次点击的时候，设置背景色的方法已经启动，在检测到双击的时候先要把先前对应的方法取消掉，可以通过调用NSObject类的<code>cancelPreviousPerformRequestWithTarget:selector:object</code>方法取消指定对象的方法调用，然后调用双击对应的方法设置背景色为红色。</p>
<p>下面举个例子创建可以拖动的视图，这个主要通过触摸对象的位置坐标来实现。因此调用触摸对象的locationInView：方法即可。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGPoint</span> originalLocation;</span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    originalLocation = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> currentLocation = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.x</span> += currentLocation<span class="variable">.x</span>-originalLocation<span class="variable">.x</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.y</span> += currentLocation<span class="variable">.y</span>-originalLocation<span class="variable">.y</span>;   </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先在<code>touchesBegan</code>中通过<code>[touch locationInView:self.view]</code>获取手指触摸在当前视图上的位置，用<code>CGPoint</code>变量记录，然后在手指移动事件touchesMoved方法中获取触摸对象当前位置，并通过于与原始位置的差值计算出移动偏移量，再设置当前视图的位置。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/10/cpp/stl_map与boost_unordered_map/">
                STL map与Boost unordered_map
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/10/cpp/stl_map与boost_unordered_map/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/10/cpp/stl_map与boost_unordered_map/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="STL_map与Boost_unordered_map">STL map与Boost unordered_map</h1><p>今天看到 boost::unordered_map， 它与 stl::map的区别就是，stl::map是按照operator&lt;比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator&lt; 定义的大小排序。</p>
<p>而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对unordered_map进行遍历，结果是无序的。</p>
<p>用法的区别就是，stl::map 的key需要定义operator&lt; 。 而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator&lt; 或者hash_value()了。 </p>
<p>最后，说，当不需要结果排好序时，最好用unordered_map。</p>
<p>其实，stl::map对于与java中的TreeMap，而boost::unordered_map对应于java中的HashMap。 </p>
<h2 id="stl::map">stl::map</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	int age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">person</span>(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;name =  name;</span><br><span class="line">		this-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const <span class="keyword">person</span>&amp; p) const</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;age &lt; p.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">person</span>,int&gt; m;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">person</span> p1(<span class="string">"Tom1"</span>,20);</span><br><span class="line">	<span class="keyword">person</span> p2(<span class="string">"Tom2"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p3(<span class="string">"Tom3"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p4(<span class="string">"Tom4"</span>,23);</span><br><span class="line">	<span class="keyword">person</span> p5(<span class="string">"Tom5"</span>,24);</span><br><span class="line">	m.insert(make_pair(p3, 100));</span><br><span class="line">	m.insert(make_pair(p4, 100));</span><br><span class="line">	m.insert(make_pair(p5, 100));</span><br><span class="line">	m.insert(make_pair(p1, 100));</span><br><span class="line">	m.insert(make_pair(p2, 100));</span><br><span class="line">	</span><br><span class="line">	for(map&lt;<span class="keyword">person</span>, int&gt;::iterator iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;iter-&gt;first.name&lt;&lt;<span class="string">"\t"</span>&lt;&lt;iter-&gt;first.age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Tom1    20</span><br><span class="line">Tom3    22</span><br><span class="line">Tom4    23</span><br><span class="line">Tom5    24</span><br></pre></td></tr></table></figure>
<blockquote>
<p>operator&lt;的重载一定要定义成const。因为map内部实现时调用operator&lt;的函数好像是const。</p>
<p>由于operator&lt;比较的只是age,所以因为Tom2和Tom3的age相同，所以最终结果里面只有Tom3，没有Tom2</p>
</blockquote>
<h2 id="boost::unordered_map">boost::unordered_map</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;boost/unordered_map.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	int age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">person</span>(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;name =  name;</span><br><span class="line">		this-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator== (const <span class="keyword">person</span>&amp; p) const</span><br><span class="line">	&#123;</span><br><span class="line">		return name==p.name &amp;&amp; age==p.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">size_t hash_value(const <span class="keyword">person</span>&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	size_t seed = 0;</span><br><span class="line">	boost::hash_combine(seed, boost::hash_value(p.name));</span><br><span class="line">	boost::hash_combine(seed, boost::hash_value(p.age));</span><br><span class="line">	return seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	typedef boost::unordered_map&lt;<span class="keyword">person</span>,int&gt; umap;</span><br><span class="line">	umap m;</span><br><span class="line">	<span class="keyword">person</span> p1(<span class="string">"Tom1"</span>,20);</span><br><span class="line">	<span class="keyword">person</span> p2(<span class="string">"Tom2"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p3(<span class="string">"Tom3"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p4(<span class="string">"Tom4"</span>,23);</span><br><span class="line">	<span class="keyword">person</span> p5(<span class="string">"Tom5"</span>,24);</span><br><span class="line">	m.insert(umap::value_type(p3, 100));</span><br><span class="line">	m.insert(umap::value_type(p4, 100));</span><br><span class="line">	m.insert(umap::value_type(p5, 100));</span><br><span class="line">	m.insert(umap::value_type(p1, 100));</span><br><span class="line">	m.insert(umap::value_type(p2, 100));</span><br><span class="line">	</span><br><span class="line">	for(umap::iterator iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;iter-&gt;first.name&lt;&lt;<span class="string">"\t"</span>&lt;&lt;iter-&gt;first.age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Tom1    20</span><br><span class="line">Tom5    24</span><br><span class="line">Tom4    23</span><br><span class="line">Tom2    22</span><br><span class="line">Tom3    22</span><br></pre></td></tr></table></figure>
<blockquote>
<p>必须要自定义operator==和hash_value。 重载operator==是因为，如果两个元素的hash_value的值相同，并不能断定这两个元素就相同，必须再调用operator==。 当然，如果hash_value的值不同，就不需要调用operator==了。</p>
</blockquote>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/08/cpp/std_function和std_bind/">
                c++11中的bind和function
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-08
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/08/cpp/std_function和std_bind/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/08/cpp/std_function和std_bind/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="c++11中的bind和function">c++11中的bind和function</h1><h2 id="std::function">std::function</h2><p>它是函数、函数对象、函数指针、和成员函数的包装器，可以容纳任何类型的函数对象，函数指针，引用函数，成员函数的指针。<br>以统一的方式处理函数、函数对象、函数指针、和成员函数。</p>
<p>允许保存和延迟执行函数。</p>
<ul>
<li>函数和成员函数作为function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">G</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">H</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f = G; <span class="comment">//全局函数</span></span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f <span class="number">1</span>= <span class="built_in">std</span>::bind(&amp;A::H, a); <span class="comment">//成员函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以用function取代函数指针。因为它可以保存函数延迟执行，所以比较适合作为回调函数，也可以把它看做类似于c#中特殊的委托，只有一个成员的委托。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">A(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&amp; f):m_callback(f)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">m_callback();<span class="comment">//回调到上层</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; m_callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>function还可以作为函数入参，这样可以在函数外部控制函数的内部行为了，让我们的函数变得更加灵活。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)</span>&gt;&amp; f)</span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">f(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x+<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFoo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(G, <span class="built_in">std</span>::placeholders::_1); </span><br><span class="line">Foo(<span class="number">4</span>, f);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Foo函数外面更改f的行为</span></span><br><span class="line">f = <span class="built_in">std</span>::bind(H, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">Foo(<span class="number">4</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std::bind绑定器">std::bind绑定器</h2><ul>
<li>将函数、成员函数和闭包转成function函数对象</li>
<li>将多元(n&gt;1)函数转成一元函数或者(n-1)元函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="comment">//绑定全局函数</span></span><br><span class="line"><span class="keyword">auto</span> f11 = <span class="built_in">std</span>::bind(H, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"><span class="keyword">auto</span>的类型实际上是<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定带参数的成员函数</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">char</span>*, <span class="keyword">int</span>)&gt; f = <span class="built_in">std</span>::bind(&amp;ReadHandler::ConnectPreProcess, <span class="keyword">this</span>, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三元函数转换成一元函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="comment">// 绑定f()函数调用的第二个和第三个参数，</span></span><br><span class="line"><span class="comment">// 返回一个新的函数对象为ff，它只带有一个int类型的参数</span></span><br><span class="line"><span class="keyword">auto</span> ff = bind(f, _1, ‘c’, <span class="number">1.2</span>);    </span><br><span class="line"><span class="keyword">int</span> x = ff(<span class="number">7</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>bind简化和增强bind1st和bind2nd</li>
</ul>
<p>其实bind简化和增强了之前标准库中bind1st和bind2nd，它完全可以替代bind1s和bind2st，并且能组合函数。我们知道bind1st和bind2nd将一个二元算子转换成一个一元算子。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素值大于10的元素的个数</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, std::bind1st<span class="params">(less&lt;int&gt;<span class="params">()</span>, <span class="number">10</span>)</span>)</span>;</span><br><span class="line"><span class="comment">//查找元素之小于10的元素</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, std::bind2nd<span class="params">(less&lt;int&gt;<span class="params">()</span>, <span class="number">10</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>本质上是对一个二元函数less<int>的调用，但是它却要分别用bind1st和bind2nd，而且还要想想到底是用bind1st还是bind2nd，用起来感觉不方便。现在用bind，就可以以统一的方式去实现了。</int></p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素值大于10的元素的个数</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, bind<span class="params">(less&lt;int&gt;<span class="params">()</span>, <span class="number">10</span>, _1)</span>)</span>;</span><br><span class="line"><span class="comment">//查找元素之小于10的元素</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, bind<span class="params">(less&lt;int&gt;<span class="params">()</span>, _1, <span class="number">10</span>)</span>)</span>;</span><br><span class="line">这样我就不用关心到底是用bind1st还是bind2nd了，只要用bind就都搞定了。</span><br></pre></td></tr></table></figure>
<ul>
<li>bind函数组合</li>
</ul>
<p>bind的还有一个强大之处就是函数组合。假设我们要找出集合中大于5小于10的元素个数怎么做呢？我们需要一个逻辑与才能做到类似于： </p>
<p><code>std::bind(std::logical_and&lt;bool&gt;(),_1,_2);</code></p>
<p>然后，我们需要另一个谓词来回答 _1 是否大于5。</p>
<p><code>std::bind(std::greater&lt;int&gt;(),_1,5);</code></p>
<p>然后，我们还需要另一个谓词来回答 _1 是否小于等于10。</p>
<p><code>std::bind(std::less_equal&lt;int&gt;(),_1,10);</code></p>
<p>最后，我们需要把它们两个用逻辑与合起来，就象这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找集合中大于5小于10的元素个数</span></span><br><span class="line"><span class="keyword">auto</span> f = bind(<span class="built_in">std</span>::logical_and&lt;<span class="keyword">bool</span>&gt;(), bind(<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">5</span>), bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">int</span> count = count_if(coll.begin(), coll.end(), f);</span><br></pre></td></tr></table></figure>
<p>c++11中推出function是为了泛化函数对象，函数指针，引用函数，成员函数的指针，让我们可以按更统一的方式写出更加泛化的代码；推出bind是为了替换和增强之前标准库的bind1st和bind2st，让我们的用起来更方便！</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/07/cpp/std_find,std_find_if/">
                std::find,std::find_if
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/07/cpp/std_find,std_find_if/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/07/cpp/std_find,std_find_if/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="std::find,std::find_if">std::find,std::find_if</h1><ul>
<li>STL的find，find_if函数提供了一种对数组、STL容器进行查找的方法。使用该函数，需 #include <algorithm>,我们查找一个list中的数据，通常用find()，例如：</algorithm></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line">	lst.push_back(<span class="number">10</span>);</span><br><span class="line">	lst.push_back(<span class="number">20</span>);</span><br><span class="line">	lst.push_back(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(lst.begin(), lst.end(), <span class="number">10</span>); <span class="comment">// 查找list中是否有元素“10”</span></span><br><span class="line">	<span class="keyword">if</span> (it != lst.end()) <span class="comment">// 找到了</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// do something </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">// 没找到</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>那么，如果容器里的元素是一个类呢？例如，有list<cperson> ，其中CPerson类定义如下：</cperson></li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CPerson(<span class="keyword">void</span>); ~CPerson(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么如何用find()函数进行查找呢？这时，我们需要提供一个判断两个CPerson对象“相等”的定义，find()函数才能从一个list中找到与指定的CPerson“相等”的元素。</p>
<p>这个“相等”的定义，是通过重载“==”操作符实现的，我们在CPerson类中添加一个方法，定义为：</p>
<p><code>bool operator==(const CPerson &amp;rhs) const;</code></p>
<p>实现为：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="attribute">CPerson</span>::operator==(<span class="keyword">const</span> CPerson &amp;rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (id == rhs.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="pi">//然后我们就可以这样查找（假设list中已经有了若干CPerson对象）了：</span><br><span class="line">list&lt;CPerson&gt; lst;</span><br><span class="line">//</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span></span><br><span class="line"><span class="pi">// 向lst中添加元素，此处省略</span><br><span class="line">//</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span></span><br><span class="line">CPerson cp_to_find; <span class="pi">// 要查找的对象</span><br><span class="line">cp_to_find.age = 50;</span><br><span class="line">list&lt;CPerson&gt;::iterator it = find(list.begin(), list.end(), cp_to_find); //</span> 查找</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">it</span> != lst.end()) <span class="pi">// 找到了</span><br><span class="line">&#123;</span><br><span class="line">	//</span> <span class="keyword">do</span> something </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="pi">// 没找到</span><br><span class="line">&#123;</span><br><span class="line">	//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有人说，如果我有自己定义的“相等”呢？例如，有一个list<cperson*>，这个list中的每一个元素都是一个对象的指针，我们要在这个list中查找具有指定age的元素，找到的话就得到对象的指针。</cperson*></li>
</ul>
<p>这时候，你不再能像上面的例子那样做，我们需要用到find_if函数，并自己指定predicate function（即find_if函数的第三个参数，请查阅STL手册）。先看看find_if函数的定义：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">InputIterator</span>, class <span class="type">Predicate</span>&gt;</span><br><span class="line">   <span class="type">InputIterator</span> find_if(<span class="type">InputIterator</span> _First, <span class="type">InputIterator</span> _Last, <span class="type">Predicate</span> _Pred);</span><br><span class="line"><span class="type">Parameters</span></span><br><span class="line">_First</span><br><span class="line"><span class="type">An</span> input <span class="keyword">iterator</span> addressing the position <span class="keyword">of</span> the first element <span class="keyword">in</span> the <span class="type">range</span> </span><br><span class="line">to be searched.</span><br><span class="line"></span><br><span class="line">_Last</span><br><span class="line"><span class="type">An</span> input <span class="keyword">iterator</span> addressing the position one past the final element <span class="keyword">in</span> the </span><br><span class="line"><span class="type">range</span> to be searched.</span><br><span class="line"></span><br><span class="line">_Pred</span><br><span class="line"><span class="type">User</span>-defined predicate function <span class="keyword">object</span> that defines the condition to be </span><br><span class="line">satisfied by the element being searched <span class="keyword">for</span>. A predicate takes single argument </span><br><span class="line"><span class="keyword">and</span> returns <span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>.</span><br></pre></td></tr></table></figure>
<p>我们在CPerson类外部定义这样一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">finder_t</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">finder_t</span>(<span class="keyword">int</span> n): age(n)	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(CPerson *p)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (age == p-&gt;age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>	age;</span><br><span class="line">&#125;<span class="keyword">finder_t</span>;</span><br></pre></td></tr></table></figure>
<p>然后就可以利用find_if函数来查找了：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list&lt;CPerson*&gt; lst;</span><br><span class="line"><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">//</span><br><span class="line">//</span> 向lst中添加元素，此处省略</span><br><span class="line"><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">//</span><br><span class="line">list&lt;CPerson*&gt;::iterator it = find_if(lst.begin(), lst.end(), finder_t(50));	//</span> 查找年龄为<span class="number">50</span>的人</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">it</span> != lst.end())	<span class="pi">// 找到了</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; "Found person with age : " &lt;&lt; (*it)-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line">else	//</span> 没找到</span><br><span class="line">&#123;</span><br><span class="line">	<span class="pi">// do something</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/06/cpp/share_ptr/">
                share_ptr
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-06
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/06/cpp/share_ptr/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/06/cpp/share_ptr/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="share_ptr">share_ptr</h1><ul>
<li>shared_ptr是一个最像指针的”智能指针”，是boost.smart_ptr库中最有价值、最重要的组成部分，也是最有用的，Boost库的许多组件—甚至还包括其他一些领域的智能指针都使用了shared_ptr。抱歉，我实在想不出什么更恰当的词汇来形容它在软件开发中的重要性。再强调一遍，shared_ptr非常有价值、非常重要、非常有用。</li>
</ul>
<ul>
<li><p>shared_ptr与scoped_ptr一样包装了new操作符在堆上分配的动态对象，但它实现的是引用计数型的智能指针 ，可以被自由地拷贝和赋值，在任意的地方共享它，当没有代码使用（引用计数为0）它时才删除被包装的动态分配的对象。shared_ptr也可以安全地放到标准容器中，并弥补了auto_ptr因为转移语义而不能把指针作为STL容器元素的缺陷。</p>
</li>
<li><p>在C++历史上曾经出现过无数的引用计数型智能指针实现，但没有一个比得上boost::shared_ptr，在过去、现在和将来，它都是最好的。</p>
</li>
</ul>
<h2 id="shared_ptr的线程安全性"><strong>shared_ptr的线程安全性</strong></h2><ul>
<li>shared_ptr 本身不是 100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为 shared_ptr 有两个数据成员，读写操作不能原子化。根据文档，shared_ptr 的线程安全级别和内建类型、标准库容器、string 一样，即：</li>
</ul>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个 <span class="annotation">shared</span><span class="number">_p</span>tr 实体可被多个线程同时读取；</span><br><span class="line">两个的 <span class="annotation">shared</span><span class="number">_p</span>tr 实体可以被两个线程同时写入，“析构”算写操作；</span><br><span class="line">如果要从多个线程读写同一个 <span class="annotation">shared</span><span class="number">_p</span>tr 对象，那么需要加锁。</span><br></pre></td></tr></table></figure>
<h2 id="shared_ptr用法"><strong>shared_ptr用法</strong></h2><p>示例一：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp<span class="params">(new int<span class="params">(<span class="number">10</span>)</span>)</span>;                <span class="comment">//一个指向整数的shared_ptr  </span></span><br><span class="line">assert<span class="params">(sp.unique<span class="params">()</span>)</span>;                            <span class="comment">//现在shared_ptr是指针的唯一持有者   </span></span><br><span class="line">shared_ptr&lt;int&gt; sp2 = sp;                       <span class="comment">//第二个shared_ptr,拷贝构造函数   </span></span><br><span class="line">assert<span class="params">(sp == sp2 &amp;&amp; sp.use_count<span class="params">()</span> == <span class="number">2</span>)</span>;		<span class="comment">//两个shared_ptr相等,指向同一个对象,引用计数为2  </span></span><br><span class="line"><span class="built_in">*</span>sp2 = <span class="number">100</span>;										<span class="comment">//使用解引用操作符修改被指对象  </span></span><br><span class="line">assert<span class="params">(*sp == <span class="number">100</span>)</span>;								<span class="comment">//另一个shared_ptr也同时被修改   </span></span><br><span class="line">sp.reset<span class="params">()</span>;                                     <span class="comment">//停止shared_ptr的使用  </span></span><br><span class="line">assert<span class="params">(!sp)</span>;                                    <span class="comment">//sp不再持有任何指针(空指针)</span></span><br></pre></td></tr></table></figure>
<p>示例一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> shared                                    <span class="comment">//一个拥有shared_ptr的类  </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:      </span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p;                          <span class="comment">//shared_ptr成员变量  </span></span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">	shared(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p_):p(p_)&#123;&#125;          <span class="comment">//构造函数初始化shared_ptr      </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>                                <span class="comment">//输出shared_ptr的引用计数和指向的值      </span></span><br><span class="line">	</span>&#123;          <span class="built_in">cout</span> &lt;&lt; <span class="string">"count:"</span> &lt;&lt; p.use_count()              </span><br><span class="line">	&lt;&lt; <span class="string">"v ="</span> &lt;&lt;*p &lt;&lt; endl;      </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_func</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p)</span>				<span class="comment">//使用shared_ptr作为函数参数  </span></span><br><span class="line"></span>&#123;       </span><br><span class="line">	<span class="comment">//同样输出shared_ptr的引用计数和指向的值      </span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"count:"</span> &lt;&lt; p.use_count()          </span><br><span class="line">		&lt;&lt; <span class="string">" v="</span> &lt;&lt;*p &lt;&lt; endl;  &#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;      </span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>));      </span><br><span class="line">	<span class="function">shared <span class="title">s1</span><span class="params">(p)</span>, <span class="title">s2</span><span class="params">(p)</span></span>;                        <span class="comment">//构造两个自定义类       </span></span><br><span class="line">	s1.print();      </span><br><span class="line">	s2.print();       </span><br><span class="line">	*p = <span class="number">20</span>;                                    <span class="comment">//修改shared_ptr所指的值      </span></span><br><span class="line">	print_func(p);      </span><br><span class="line">	s1.print();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用于标准容器">应用于标准容器</h2><p>有两种方式可以将shared_ptr应用于标准容器（或者容器适配器等其他容器）。</p>
<p>一种用法是将容器作为shared_ptr管理的对象，如shared_ptr<list<t> &gt;，使容器可以被安全地共享，用法与普通shared_ptr没有区别，我们不再讨论。</list<t></p>
<p>另一种用法是将shared_ptr作为容器的元素，如vector<shared_ptr<t> &gt;，因为shared_ptr支持拷贝语义和比较操作，符合标准容器对元素的要求，所以可以实现在容器中安全地容纳元素的指针而不是拷贝。</shared_ptr<t></p>
<p>标准容器不能容纳auto_ptr，这是C++标准特别规定的（读者永远也不要有这种想法）。标准容器也不能容纳scoped_ptr，因为scoped_ptr不能拷贝和赋值。标准容器可以容纳原始指针，但这就丧失了容器的许多好处，因为标准容器无法自动管理类型为指针的元素，必须编写额外的大量代码来保证指针最终被正确删除，这通常很麻烦很难实现。</p>
<p>存储shared_ptr的容器与存储原始指针的容器功能几乎一样，但shared_ptr为程序员做了指针的管理工作，可以任意使用shared_ptr而不用担心资源泄漏。</p>
<p>下面的代码示范了将shared_ptr应用于标准容器的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;boost/make_shared.hpp&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;      </span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; vs;    <span class="comment">//一个持有shared_ptr的标准容器类型      </span></span><br><span class="line">	<span class="function">vs <span class="title">v</span><span class="params">(10)</span></span>;                               <span class="comment">//声明一个拥有10个元素的容器，元素被初始化为空指针       </span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;      </span><br><span class="line">	<span class="keyword">for</span> (vs::iterator pos = v.begin(); pos != v.end(); ++pos)      </span><br><span class="line">	&#123;          </span><br><span class="line">		(*pos) = make_shared&lt;<span class="keyword">int</span>&gt;(++i);     <span class="comment">//使用工厂函数赋值          </span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *(*pos) &lt;&lt; <span class="string">", "</span>;            <span class="comment">//输出值      </span></span><br><span class="line">	&#125;      </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;       </span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p = v[<span class="number">9</span>];      </span><br><span class="line">	*p = <span class="number">100</span>;      </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *v[<span class="number">9</span>] &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码需要注意的是迭代器和operator[]的用法，因为容器内存储的是shared_ptr，我们必须对迭代器pos使用一次解引用操作符*以获得shared_ptr，然后再对shared_ptr使用解引用操作符*才能操作真正的值。*(*pos)也可以直接写成**pos，但前者更清晰，后者很容易让人迷惑。vector的operator[]用法与迭代器类似，也需要使用*获取真正的值。</p>
</blockquote>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/05/cpp/pair与make_pair/">
                C++ std::pair 与 std::make_pair
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-05
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/05/cpp/pair与make_pair/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/05/cpp/pair与make_pair/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="C++_std::pair_与_std::make_pair">C++ std::pair 与 std::make_pair</h1><ul>
<li>std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。例如std::pair<int,float> 或者 std：：pair<double,double>等。pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：</double,double></int,float></li>
</ul>
<p><code>template pair make_pair(T1 a, T2 b) { return pair(a, b); }</code></p>
<ul>
<li>一般make_pair都使用在需要pair做参数的位置，可以直接调用make_pair生成pair对象。 另一个使用的方面就是pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题：例如有如下两个定义：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">std</span>:<span class="value">:pair&lt;int, float&gt;(<span class="number">1</span>, <span class="number">1.1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="rule"><span class="attribute">std</span>:<span class="value">:<span class="function">make_pair</span>(<span class="number">1</span>, <span class="number">1.1</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中第一个的second变量是float类型，而make_pair函数会将second变量都转换成double类型。这个问题在编程是需要引起注意。下面是一段pair与make_pair的例子程序： </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  pair &lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product1 (<span class="string">"tomatoes"</span>,<span class="number">3.25</span>);</span><br><span class="line">  pair &lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product2;</span><br><span class="line">  pair &lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product3;</span><br><span class="line">  product2.first = <span class="string">"lightbulbs"</span>;     <span class="comment">// type of first is string</span></span><br><span class="line">  product2.second = <span class="number">0.99</span>;            <span class="comment">// type of second is double</span></span><br><span class="line">  product3 = make_pair (<span class="string">"shoes"</span>,<span class="number">20.0</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product1.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product1.second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product2.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product2.second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product3.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product3.second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">其运行结果如下：</span><br><span class="line"><span class="number">1</span> The price of tomatoes is $<span class="number">3.25</span></span><br><span class="line"><span class="number">2</span> The price of lightbulbs is $<span class="number">0.99</span></span><br><span class="line"><span class="number">3</span> The price of shoes is $<span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为了更好的了解pair与make_pair的机制，下面是其定义：</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class _Ty1,class _Ty2&gt; struct pair</span><br><span class="line">&#123;   // store a pair <span class="keyword">of</span> values</span><br><span class="line">    typedef pair&lt;_Ty1, _Ty2&gt; _Myt;</span><br><span class="line">    typedef _Ty1 first_type;</span><br><span class="line">    typedef _Ty2 second_type;</span><br><span class="line"></span><br><span class="line">    pair(): first(_Ty1()), second(_Ty2())</span><br><span class="line">        &#123;    // construct <span class="keyword">from</span> defaults</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    pair(<span class="keyword">const</span> _Ty1&amp; _Val1, <span class="keyword">const</span> _Ty2&amp; _Val2): first(_Val1), second(_Val2)</span><br><span class="line">        &#123;    // construct <span class="keyword">from</span> specified values</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;class _Other1,</span><br><span class="line">        class _Other2&gt;</span><br><span class="line">        pair(<span class="keyword">const</span> pair&lt;_Other1, _Other2&gt;&amp; _Right)</span><br><span class="line">        : first(_Right.first), second(_Right.second)</span><br><span class="line">        &#123;    // construct <span class="keyword">from</span> compatible pair</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> swap(_Myt&amp; _Right)</span><br><span class="line">        &#123;    // exchange contents <span class="keyword">with</span> _Right</span><br><span class="line">        std::swap(first, _Right.first);</span><br><span class="line">        std::swap(second, _Right.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    _Ty1 first;    // the first stored value</span><br><span class="line">    _Ty2 second;    // the second stored value</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class _Ty1,class _Ty2&gt; inline</span><br><span class="line">    pair&lt;_Ty1, _Ty2&gt; make_pair(_Ty1 _Val1, _Ty2 _Val2)</span><br><span class="line">    &#123;    // <span class="keyword">return</span> pair composed <span class="keyword">from</span> arguments</span><br><span class="line">    <span class="keyword">return</span> (pair&lt;_Ty1, _Ty2&gt;(_Val1, _Val2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/04/cpp/function_bind_lambda/">
                function, bind和lambda
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-04
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/04/cpp/function_bind_lambda/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/04/cpp/function_bind_lambda/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="本文是C++0x系列的第四篇，主要是内容是C++0x中新增的lambda表达式,_function对象和bind机制。之所以把这三块放在一起讲，是因为这三块之间有着非常密切的关系，通过对比学习，加深对这部分内容的理解。在开始之间，首先要讲一个概念，closure（闭包），这个概念是理解lambda的基础。下面我们来看看wikipedia上对于计算机领域的closure的定义：">本文是C++0x系列的第四篇，主要是内容是C++0x中新增的lambda表达式, function对象和bind机制。之所以把这三块放在一起讲，是因为这三块之间有着非常密切的关系，通过对比学习，加深对这部分内容的理解。在开始之间，首先要讲一个概念，closure（闭包），这个概念是理解lambda的基础。下面我们来看看wikipedia上对于计算机领域的closure的定义：</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A closure (also lexical closure, <span class="keyword">function</span> closure <span class="keyword">or</span> <span class="keyword">function</span> value) <span class="keyword">is</span> a <span class="keyword">function</span> together <span class="keyword">with</span></span><br><span class="line">a referencing environment <span class="keyword">for</span> the non-local variables <span class="keyword">of</span> <span class="literal">that</span> <span class="keyword">function</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  上面的大义是说，closure是一个函数和它所引用的非本地变量的上下文环境的集合。从定义我们可以得知，closure可以访问在它定义范围之外的变量，也即上面提到的non-local vriables，这就大大增加了它的功力。关于closure的最重要的应用就是回调函数，这也是为什么这里把function, bind和lambda放在一起讲的主要原因，它们三者在使用回调函数的过程中各显神通。下面就为大家一步步接开这三者的神秘面纱。</p>
</blockquote>
<h3 id="function-">function.</h3><p>我们知道，在C++中，可调用实体主要包括函数，函数指针，函数引用，可以隐式转换为函数指定的对象，或者实现了opetator()的对象（即C++98中的functor)。C++0x中，新增加了一个std::function对象，std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。我们来看几个关于function对象的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt; functional&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::function&lt; <span class="keyword">size_t</span>(<span class="keyword">const</span> <span class="keyword">char</span>*)&gt; print_func;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// normal function -&gt; std::function object</span></span><br><span class="line"><span class="keyword">size_t</span> CPrint(<span class="keyword">const</span> <span class="keyword">char</span>*) &#123; ... &#125;</span><br><span class="line">print_func = CPrint;</span><br><span class="line">print_func(<span class="string">"hello world"</span>):</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// functor -&gt; std::function object</span></span><br><span class="line"><span class="keyword">class</span> CxxPrint</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="keyword">char</span>*) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CxxPrint p;</span><br><span class="line">print_func = p;</span><br><span class="line">print_func(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   在上面的例子中，我们把一个普通的函数和一个functor赋值给了一个std::function对象，然后我们通过该对象来调用。其它的C++中的可调用实体都可以像上面一样来使用。通过std::function的包裹，我们可以像传递普通的对象一样来传递可调用实体，这样就很好解决了类型安全的问题。了解了std::function的基本用法，下面我们来看一些使用过程中的注意事项：</p>
</blockquote>
<ol>
<li>关于可调用实体转换为std::function对象需要遵守以下两条原则：<br>a. 转换后的std::function对象的参数能转换为可调用实体的参数<br>b. 可高用实体的返回值能转换为std::function对象的（这里注意一下，所有的可调用实体的返回值都与返回void的std::function对象的返回值兼容）。</li>
<li>std::function对象可以refer to满足（1）中条件的任意可调用实体</li>
<li>std::function object最大的用处就是在实现函数回调，使用者需要注意，它不能被用来检查相等或者不相等</li>
</ol>
<h3 id="bind">bind</h3><p>   bind是这样一种机制，它可以预先把指定可调用实体的某些参数绑定到已有的变量，产生一个新的可调用实体，这种机制在回调函数的使用过程中也颇为有用。C++98中，有两个函数bind1st和bind2nd，它们分别可以用来绑定functor的第一个和第二个参数，它们都是只可以绑定一个参数。各种限制，使得bind1st和bind2nd的可用性大大降低。C++0x中，提供了std::bind，它绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定，这个bind才是真正意义上的绑定，有了它，bind1st和bind2nd就没啥用武之地了，因此C++0x中不推荐使用bind1st和bind2nd了，都是deprecated了。下面我们通过例子，来看看bind的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt; functional&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> bf1 = <span class="built_in">std</span>::bind(Func, <span class="number">10</span>, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">bf1(<span class="number">20</span>); <span class="comment">///&lt; same as Func(10, 20)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">auto</span> bf2 = <span class="built_in">std</span>::bind(&amp;A::Func, a, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_2);</span><br><span class="line">bf2(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">///&lt; same as a.Func(10, 20)</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::function&lt; <span class="keyword">int</span>(<span class="keyword">int</span>)&gt; bf3 = <span class="built_in">std</span>::bind(&amp;A::Func, a, <span class="built_in">std</span>::placeholders::_1, <span class="number">100</span>);</span><br><span class="line">bf3(<span class="number">10</span>); <span class="comment">///&lt; same as a.Func(10, 100)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>   上面的例子中，bf1是把一个两个参数普通函数的第一个参数绑定为10，生成了一个新的一个参数的可调用实体体; bf2是把一个类成员函数绑定了类对象，生成了一个像普通函数一样的新的可调用实体; bf3是把类成员函数绑定了类对象和第二个参数，生成了一个新的std::function对象。看懂了上面的例子，下面我们来说说使用bind需要注意的一些事项：</p>
</blockquote>
<ol>
<li>bind预先绑定的参数需要传具体的变量或值进去，对于预先绑定的参数，是pass-by-value的</li>
<li>对于不事先绑定的参数，需要传std::placeholders进去，从_1开始，依次递增。placeholder是pass-by-reference的</li>
<li>bind的返回值是可调用实体，可以直接赋给std::function对象</li>
<li>对于绑定的指针、引用类型的参数，使用者需要保证在可调用实体调用之前，这些参数是可用的</li>
<li>类的this可以通过对象或者指针来绑定</li>
</ol>
<h3 id="lambda">lambda</h3><p> 讲完了function和bind, 下面我们来看lambda。有python基础的朋友，相信对于lambda不会陌生。看到这里的朋友，请再回忆一下前面讲的closure的概念，lambda就是用来实现closure的东东。它的最大用途也是在回调函数，它和前面讲的function和bind有着千丝万缕的关系。下面我们先通过例子来看看lambda的庐山真面目：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="comment">/// 1. simple lambda</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(vec.begin(), vec.end(), [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; <span class="number">50</span>; &#125;);</span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> i &gt; <span class="number">50</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(vec.begin(), vec.end(), A());</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 2. lambda return syntax</span></span><br><span class="line"><span class="built_in">std</span>::function&lt; <span class="keyword">int</span>(<span class="keyword">int</span>)&gt; square = [](<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> i * i; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 3. lambda expr: capture of local variable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> min_val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> max_val = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(vec.begin(), vec.end(), [=](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; min_val &amp;&amp; i &lt; max_val; </span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(vec.begin(), vec.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; min_val &amp;&amp; i &lt; max_val;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(vec.begin(), vec.end(), [=, &amp;max_value](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; min_val &amp;&amp; i &lt; max_val;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 4. lambda expr: capture of class member</span></span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  m_vec;</span><br><span class="line">    <span class="keyword">int</span>               m_min_val;</span><br><span class="line">    <span class="keyword">int</span>               m_max_va;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 4.1 capture member by this</span></span><br><span class="line"><span class="keyword">void</span> A::DoSomething()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(m_vec.begin(), m_vec.end(), [<span class="keyword">this</span>](<span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; m_min_val &amp;&amp; i &lt; m_max_val; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 4.2 capture member by default pass-by-value</span></span><br><span class="line"><span class="keyword">void</span> A::DoSomething()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(m_vec.begin(), m_vec.end(), [=](<span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; m_min_val &amp;&amp; i &lt; m_max_val; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 4.3 capture member by default pass-by-reference</span></span><br><span class="line"><span class="keyword">void</span> A::DoSomething()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find_if(m_vec.begin(), m_vec.end(), [&amp;](<span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; m_min_val &amp;&amp; i &lt; m_max_val; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子基本覆盖到了lambda表达的基本用法。我们一个个来分析每个例子（标号与上面代码注释中1，2，3，4一致）：</p>
<ol>
<li>这是最简单的lambda表达式，可以认为用了lambda表达式的find_if和下面使用了functor的find_if是等价的</li>
<li>这个是有返回值的lambda表达式，返回值的语法如上面所示，通过-&gt;写在参数列表的括号后面。返回值在下面的情况下是可以省略的：<br>a. 返回值是void的时候<br>b. lambda表达式的body中有return expr，且expr的类型与返回值的一样</li>
<li>这个是lambda表达式capture本地局部变量的例子，这里三个小例子，分别是capture时不同的语法，第一个小例子中=表示capture的变量pass-by-value, 第二个小拿出中&amp;表示capture的变量pass-by-reference，第三个小例子是说指定了default的pass-by-value, 但是max_value这个单独pass-by-reference</li>
<li>这个是lambda表达式capture类成员变量的例子，这里也有三个小例子。第一个小例子是通过this指针来capture成员变量，第二、三个是通过缺省的方式，只不过第二个是通过pass-by-value的方式，第三个是通过pass-by-reference的</li>
</ol>
<p><strong>分析完了上面的例子，我们来总结一下关于lambda表达式使用时的一些注意事项：</strong></p>
<ol>
<li>lambda表达式要使用引用变量，需要遵守下面的原则：<br>a. 在调用上下文中的局部变量，只有capture了才可以引用（如上面的例子3所示）<br>b. 非本地局部变量可以直接引用</li>
<li>使用者需要注意，closure（lambda表达式生成的可调用实体）引用的变量（主要是指针和引用），在closure调用完成之前，必须保证可用，这一点和上面bind绑定参数之后生成的可调用实体是一致的</li>
<li>关于lambda的用处，就是用来生成closure，而closure也是一种可调用实体，所以可以通过std::function对象来保存生成的closure，也可以直接用auto</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/02/cpp/cpp笔记API文档/">
                C++常用函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-02
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/02/cpp/cpp笔记API文档/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/02/cpp/cpp笔记API文档/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="std::string_常用函数"><code>std::string</code> 常用函数</h2><table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.empty()</code></td>
<td>如果 s 为空串,则返回 true,否则返回 false。  </td>
</tr>
<tr>
<td><code>s.size()</code></td>
<td>返回 s 中字符的个数 </td>
</tr>
<tr>
<td><code>s[n]</code></td>
<td>返回 s 中位置为 n 的字符,位置从 0 开始计数</td>
</tr>
<tr>
<td><code>s1 + s2</code></td>
<td>把 s1 和 s2 连接成一个新字符串,返回新生成的字符串</td>
</tr>
<tr>
<td><code>s1 = s2</code></td>
<td>￼把 s1 内容替换为 s2 的副本</td>
</tr>
<tr>
<td><code>v1 == v2</code></td>
<td>比较 v1 与 v2 的内容,相等则返回 true,否则返 回 false</td>
</tr>
<tr>
<td><code>!=,&lt;,&lt;=,&gt;,and&gt;=</code></td>
<td>￼保持这些操作符惯有的含义</td>
</tr>
</tbody>
</table>
<h2 id="std::string_对象中字符的处理"><code>std::string</code> 对象中字符的处理</h2><table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isalnum(c)</code></td>
<td>如果 c 是字母或数字,则为 True。</td>
</tr>
<tr>
<td><code>isalpha(c)</code></td>
<td>如果 c 是字母,则为 true。</td>
</tr>
<tr>
<td><code>iscntrl(c)</code></td>
<td>如果 c 是控制字符,则为 true</td>
</tr>
<tr>
<td><code>isdigit(c)</code></td>
<td>如果 c 是数字,则为 true。</td>
</tr>
<tr>
<td><code>isgraph(c)</code></td>
<td>如果 c 不是空格,但可打印,则为 true。</td>
</tr>
<tr>
<td><code>islower(c)</code></td>
<td>如果 c 是小写字母,则为 true。</td>
</tr>
<tr>
<td><code>isprint(c)</code></td>
<td>如果 c 是可打印的字符,则为 true。</td>
</tr>
<tr>
<td><code>ispunct(c)</code></td>
<td>如果 c 是标点符号,则 true。</td>
</tr>
<tr>
<td><code>isspace(c)</code></td>
<td>如果 c 是空白字符,则为 true。</td>
</tr>
<tr>
<td><code>isupper(c)</code></td>
<td>如果 c 是大写字母,则 true。</td>
</tr>
<tr>
<td><code>isxdigit(c)</code></td>
<td>如果是 c 十六进制数,则为 true。</td>
</tr>
<tr>
<td><code>tolower(c)</code></td>
<td>如果 c 大写字母,返回其小写字母形式,否则直接返回 c。</td>
</tr>
<tr>
<td><code>toupper(c)</code></td>
<td>如果 c 是小写字母,则返回其大写字母形式,否则直接返回 c。</td>
</tr>
</tbody>
</table>
<h2 id="初始化_std::vector">初始化 <code>std::vector</code></h2><table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vector&lt;T&gt; v1;</code></td>
<td>vector 保存类型为 T 对象。</td>
</tr>
<tr>
<td>￼</td>
<td>默认构造函数 v1 为空。</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v2(v1);</code></td>
<td>v2 是 v1 的一个副本。</td>
</tr>
<tr>
<td>￼<code>vector&lt;T&gt; v3(n, i);</code></td>
<td>v3 包含 n 个值为 i 的元素。</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v4(n);</code></td>
<td>￼v4 含有值初始化的元素的 n 个副本。</td>
</tr>
</tbody>
</table>
<h2 id="std::vector_操作"><code>std::vector</code> 操作</h2><table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v.empty()</code></td>
<td>如果 v 为空,则返回 true,否则返回 false。</td>
</tr>
<tr>
<td><code>￼￼￼￼￼v.size()</code></td>
<td>返回 v 中元素的个数。</td>
</tr>
<tr>
<td><code>￼v.empty()</code></td>
<td>如果 v 为空,则返回 true,否则返回 false。</td>
</tr>
<tr>
<td><code>￼v.push_back(t)</code></td>
<td>在 v 的末尾增加一个值为 t 的元素。</td>
</tr>
<tr>
<td><code>v[n]</code></td>
<td>返回 v 中位置为 n 的元素。</td>
</tr>
<tr>
<td>￼￼<code>v1 = v2</code></td>
<td>把 v1 的元素替换为 v2 中元素的副本。</td>
</tr>
<tr>
<td><code>v1 == v2</code></td>
<td>如果 v1 与 v2 相等,则返回 true。￼￼</td>
</tr>
</tbody>
</table>
<h2 id="初始化std::bitset对象的方法">初始化<code>std::bitset</code>对象的方法</h2><table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bitset&lt;n&gt; b;</code></td>
<td>b 有 n 位,每位都0</td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(u);</code></td>
<td>b 是 unsigned long 型 u 的一个副本</td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(s);</code></td>
<td>b 是 string 对象 s 中含有的位串的副本</td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(s, pos, n);</code></td>
<td>￼b 是 s 中从位置 pos 开始的n个位的副本</td>
</tr>
</tbody>
</table>
<h2 id="bitset_操作">bitset 操作</h2><table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>b.any()</code></td>
<td>b 中是否存在置为 1 的二进制位?</td>
</tr>
<tr>
<td><code>￼b.none()</code></td>
<td>b 中不存在置为 1 的二进制位吗?</td>
</tr>
<tr>
<td><code>b.count()</code></td>
<td>b 中置为 1 的二进制位的个数</td>
</tr>
<tr>
<td><code>b.size()</code></td>
<td>b 中二进制位的个数</td>
</tr>
<tr>
<td><code>b[pos]</code></td>
<td>访问 b 中在 pos 处二进制位</td>
</tr>
<tr>
<td><code>b.test(pos)</code></td>
<td>b 中在 pos 处的二进制位置为 1么?</td>
</tr>
<tr>
<td><code>b.set()</code></td>
<td>把 b 中所有二进制位都置为 1</td>
</tr>
<tr>
<td>￼￼￼￼￼<code>b.set(pos)</code></td>
<td>把 b 中在 pos 处的二进制位置为 1</td>
</tr>
<tr>
<td><code>b.reset()</code></td>
<td>把 b 中所有二进制位都置为 0</td>
</tr>
<tr>
<td><code>b.reset(pos)</code></td>
<td>把 b 中在 pos 处的二进制位置为 0</td>
</tr>
<tr>
<td><code>b.flip()</code></td>
<td>把 b 中所有二进制位逐位取反</td>
</tr>
<tr>
<td><code>b.flip(pos)</code></td>
<td>把 b 中在 pos 处的二进制位取反</td>
</tr>
<tr>
<td><code>b.to_ulong()</code></td>
<td>用 b 中同样的二进制位返回一个 unsigned long 值</td>
</tr>
<tr>
<td><code>os &lt;&lt; b</code></td>
<td>把 b 中的位集输出到 os 流</td>
</tr>
</tbody>
</table>
<p>￼</p>
<h2 id="操纵_C_风格字符串的标准库函数">操纵 C 风格字符串的标准库函数</h2><table>
<thead>
<tr>
<th>函数名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>strlen(s)</code></td>
<td>返回 s 的长度,不包括字符串结束符 null</td>
</tr>
<tr>
<td><code>strcmp(s1, s2)</code></td>
<td>比较两个字符串 s1 和 s2 是否相同。若 s1 与 s2 相等,返 回 0;若 s1 大于 s2,返回正数;若 s1 小于 s2,则返回负 数</td>
</tr>
<tr>
<td><code>strcat(s1, s2)</code></td>
<td>将字符串 s2 连接到 s1 后,并返回 s1</td>
</tr>
<tr>
<td><code>strcpy(s1, s2)</code></td>
<td>将 s2 复制给 s1,并返回 s1</td>
</tr>
<tr>
<td><code>strncat(s1,s2,n)</code></td>
<td>将 s2 的前 n 个字符连接到 s1 后面,并返回 s1</td>
</tr>
<tr>
<td><code>strncpy(s1,s2, n)</code></td>
<td>将 s2 的前 n 个字符复制给 s1,并返回 s1</td>
</tr>
</tbody>
</table>
<p>￼￼</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="zhulei" />
          <p class="site-author-name">zhulei</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">65</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">46</span>
              <span class="site-state-item-name">標籤</span>
              
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/zl8522115" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://twitter.com/zl8522115" target="_blank">Twitter</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/zlsky" target="_blank">Weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/zhu-lei-46-87" target="_blank">ZhiHu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2012 - 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">zhulei</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"threestone"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

</body>
</html>
