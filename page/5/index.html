<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>




  <meta name="keywords" content="zhulei,golang,js,php,opengl" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> Three Stone </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Three Stone</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首頁
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          關於
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          歸檔
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/10/24/golang/反射规则/">
                反射规则 the law of reflection
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-10-24
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/golang/">golang</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/10/24/golang/反射规则/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/24/golang/反射规则/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="类型和接口(type_and_interfaces)">类型和接口(type and interfaces)</h2><p>因为接口是基于类型系统的（type system），所以首先看下一下go的类型</p>
<p>go是静态类型的。每个变量都有一个静态的类型(static type)，也就是说一种类型在编译的时候被声明和确定了(one type known and fixed at complie time)。如果我们定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   i的类型是int，j的类型是MyInt，i和j的类型是不一样的。尽管他们有着相同的底层类型(?)(underlying type)，但是它们是不能在不转换的情况下互相赋值的。</p>
</blockquote>
<p>类型里面一个重要的分类是接口类型(interface types)，它表示一系列的固定方法。一个接口变量可以存储任何实现这个结构的实际变量(? concrete type)。<br>一个出名的例子就是io包里的io.Reader和io.Writer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   任何类型以上面的特征(? with this signature)实现了Read（或者 Writer）方法，就可以说该类型实现了io.Read（或者io.Writer）。</p>
</blockquote>
<p>这就意味着接口io.Read类型的变量可以存放任何有Read方法的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = os.Stdin</span><br><span class="line">r = bufio.NewReader(r)</span><br><span class="line">r = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="comment">// and so on</span></span><br></pre></td></tr></table></figure>
<p>有一点要搞清楚，不管r里面存放的具体值是什么，r的类型一直都是io.Read：go是静态类型的语言，r的静态类型是io.Read。<br>一个关于接口的非常重要的例子就是空接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代表一个空的方法集，可以存放任何数据类型。因为每个类型都有零个或者更多的方法。<br>有人说go的接口是动态类型(dynamically typed)，这是一种误导。他们其实是静态的类型：一个接口类型的变量一直都有同样的静态类型(static type)，虽然在运行的时候存放在接口类型变量里的值可能会变，但是那些值都会是实现过这个接口的。</p>
<p>我们需要严谨对待上面这些概念，因为反射和接口是紧密相连的。</p>
<h2 id="关于接口的说明（the_representation_of_an_interface）">关于接口的说明（the representation of an interface）</h2><p>一个接口类型的变量是成对存储的(stores a pair)：分配给变量的具体值(concrete value)和该值的类型描述(value’s type descriptor)。更准确说，这个值是实现了该接口的底层具体数据(? the underlaying concrete data item)，类型(type)描述表示这个数据的所有类型信息(the type describes the full type of that item)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">"/dev/tty"</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure>
<p>r包含了值对(the pair)，【value,type】，【tty,<em>os.File】。这里要注意类型</em>os.File继承了不止read一个方法。<br>尽管这里的接口类型只提供Read一种方法，但是值(value)里面带有这个关于这个数值的所有信息。这就是为什么我们这么做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>
<p>这里的赋值表达式是一个类型声明(type assertion)。这个所声明里，r中的元素同时也继承了io.Writer，所以我们可以赋值给w。赋值以后，w就会存有值对(pair):【tty，*os.File】。和存放在r中的值对是一样的。接口的静态类型要求接口变量只能使用接口里所定义的方法，尽管接口变量中存放的值(value)可能拥有大量额方法。</p>
<p>继续上面的例子，我们还可以这么做：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br></pre></td></tr></table></figure></p>
<p>这的空接口变量，empty，一样的包含有同上面相同的值对(pair)，【tty，*os.File】。也就是说一个空的接口能存放所有的变量，包含有关于这个变量我们所需要的所有信息。</p>
<blockquote>
<p>   我们这不需要一个类型声明，是因为我们都知道w是符合空接口的。在这个例子里，我们把Read转换成Writer，我们是需要特别的类型声明的，这是因为Writer的方法不是Reader方法的子集。</p>
</blockquote>
<p>注意一个重要的细节，存放在接口变量中的pai存放的类型一直都是【value,concrete type】，而不是【value,interface type】。接口中不保存接口变量。</p>
<h2 id="反射的第一法则[从接口变量到反射对象的反射(reflection_goes_from_interface_value_to_reflection_object)]">反射的第一法则[从接口变量到反射对象的反射(reflection goes from interface value to reflection object)]</h2><p>简单的说，反射只是检查存放在一个接口变量里的类型和值对（type and value pair）的机制。要了解这些，我们需要知道reflect包里的两个类型：Type和Value。这个两个类型提供了访问结构变量里内容的途径，两个函数，reflect.TypeOf和reflect.ValueOf，可以获得从一个接口数据里面获取reflect.Type和reflect.Value。（当然从reflect.Value里面也能很很容易的获得reflect.Type，但是我们现在暂时把Value和Type的概念区分开）</p>
<p>让我们先来看看TypeOf:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">	 fmt.Println(<span class="string">"type:"</span>, reflect.TypeOf(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: type: float64</span></span><br></pre></td></tr></table></figure></p>
<p>你可能会好奇，这里哪有接口？程序里里面我们传递给reflect.TypeOf的x变量时float64，而不是接口啊。但是跟据godoc里显示，reflect.TypeOf的声明里包含有一个空的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeOf returns the reflection Type of the value in the interface&#123;&#125;.</span></span><br><span class="line"><span class="comment">// TypeOf(nil) returns nil.</span></span><br><span class="line"><span class="keyword">func</span> TypeOf(i <span class="keyword">interface</span>&#123;&#125;) Type &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>reflect.TypeOf(x)</code>时，x首先被存放在一个空的接口中，然后被当成参数传递过去。reflect.Typeof拆开（unpacks）这个空的接口，获取类型的信息（type information）。</p>
<p>那么reflect.ValueOf函数自然是用来获取值（value）的（这里我们忽略样板（? boilerplate），先关注可执行的代码）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, reflect.ValueOf(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: value: &lt;float64 Value&gt;</span></span><br></pre></td></tr></table></figure>
<p>reflect.Type和reflect.ValueOf都拥有很多的方法供我们使用。一个非常重要的例子就是Value有一个Type的方法，这个方法可以从refelct.Value中获得Type。另外一个Type和Value都有的方法是Kind，这个方法可以返回一个常量说明（? a constant indicating(底层类型,例如:int,float)），类似：Uint和Float64等等。同时Value里面还有类似Int和Float的函数，能让我们获取其中获取的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">"kind is float64:"</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, v.Float())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	type: float64</span></span><br><span class="line"><span class="comment">//			kind is float64: true</span></span><br><span class="line"><span class="comment">//			value: 3.4</span></span><br></pre></td></tr></table></figure>
<p>这里还有类似SetInt和SetFloat的方法，但是使用这些方法前我们需要了解settability（？）这个是下面第三部分才能谈到的，待会再讨论。</p>
<p>反射库里面有两个属性需要特别指出来。第一，为了让api简单，Value的setter和getter方法都是基于可以用来保存数据的最大数据类型的：比如所有的有符号整形操作都是基于int64的。也就是说，Value的Int方法返回一个int64的数据，而SetInt的方法获取的是一个int64。用实际的例子里说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">uint8</span> = <span class="string">'x'</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())<span class="comment">// uint8.</span></span><br><span class="line">fmt.Println(<span class="string">"kind is uint8: "</span>, v.Kind() == reflect.Uint8) <span class="comment">// true.</span></span><br><span class="line">x = <span class="typename">uint8</span>(v.Uint())<span class="comment">// v.Uint returns a uint64.</span></span><br></pre></td></tr></table></figure>
<p>第二是属性，反射对象的Kind方法描述的是底层类型（underlying type），不是静态类型。如果一个反射对象包含有一个用户自定义类型，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure>
<p>v的Kind方法返回值依旧是reflect.Int，尽管x的静态类型是MyInt而不是int。也就是说，Kind方法不能识别基于int的MyInt类型，尽管Type是可以的。</p>
<h2 id="反射的第二法则[从反射对象到接口变量的反射(reflection_goes_from_reflection_object_to_interface_value)]">反射的第二法则[从反射对象到接口变量的反射(reflection goes from reflection object to interface value)]</h2><p>就像物理世界中的反射，Go中的反射也有自己反转(inverse)。</p>
<p>给我一个reflect.Value，我们就可以通过Interface这个方法重新得到一个接口。实际上，这个方法吧type和value信息打包成一个接口引用，并且返回：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface returns v's value as an interface&#123;&#125;.</span></span><br><span class="line"><span class="keyword">func</span> (v Value) Interface() <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们可以这么说：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y := v.Interface().(<span class="typename">float64</span>) <span class="comment">// y will have type float64.</span></span><br><span class="line">fmt.Println(y)	<span class="comment">//把有对象v所表示的float64的值答应出来了。</span></span><br></pre></td></tr></table></figure>
<p>我们还可以加以改进。fmt.Println，fmt.Printf等等函数的参数都是以一个空的接口变量传递过去的，也就是说就像我们在之前的例子里一样，这个参数在fmt包里被解包（unpacked）了。所以只要给上面的函数直接传递Interface方法的返回值就能正确的输出内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Interface())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   （为什么不直接使用fmt.Println(v)？这是因为v其实是一个reflect.Value；我们需要的是里面保存的确定的值(? concrete value)）。</p>
</blockquote>
<p>既然我们的值的类型是float64，我们甚至可以使用浮点数类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"value is %7.1e\n"</span>, v.Interface())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: 3.4e+00</span></span><br></pre></td></tr></table></figure>
<p>再说一遍，我们不需要把v.Interface的结果类型转换（? type-assert）。这个空的接口值里面包含有具体数据的类型信息，Printf可以从中获取的到。</p>
<p>简单的说，Interface是函数ValueOf的反转，只可惜的是它的结果都是静态类型interface{}</p>
<p>小结：从接口反射到反射变量，然后又反射回来。</p>
<h2 id="反射的第三法则[要想修改一个反射对象，值必须是可设置的(to_modify_a_reflection_object,the_value_must_be_settable)]">反射的第三法则[要想修改一个反射对象，值必须是可设置的(to modify a reflection object,the value must be settable)]</h2><p>第三条法则是很为微妙(subtle)和让人困惑的(confusing)，但是我们从第一法则(principles)来看的话的，也是很容搞懂的。</p>
<p>下面这些代码无法运行，但是值得我们学习：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//output: panic: reflect.Value.SetFloat using unaddressable value</span></span><br></pre></td></tr></table></figure>
<p>会触发panic，产生一段含混不清的提示，其实问题并不是常量7.1无法寻址，是因为v是不可设置的（not settable）。可设置(settableility)是反射Value的一个属性，但不是所有的反射Value都有这个属性。</p>
<p>Value的CanSet方法可以判断Value可不可设置，如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: settability of v: false</span></span><br></pre></td></tr></table></figure>
<p>对一个不可设置（non-settable）的Value使用set就会报错。那么什么是可设置性（settabiliy）？<br>可设置性有点像可寻址(addressability)，但是更加严格，它是表示一个反射对象可不可修改创建这个反射对象原始存储数据(storage)的属性</p>
<p>可设置性取决于反射对象中保存的是不是原始的数据。当我们输入一下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure></p>
<p>我们传递给reflection.ValueOf的是一个x的拷贝，所以作为reflect.ValueOf的参数用来反射对象的接口，其实x的拷贝，而不是x本身。因此如果下面的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>   理论上是允许运行成功的，只是不会去修改x的值，尽管看起来v是由x创建的一样。其实这样操作会更新x的拷贝在内存中的值，而x本身是不会受到影响的。这样的话会显得让人困惑，而且一点用的都没有。所以这种方法就被规定为非法的，可设置属性是不允许这么操作的。</p>
</blockquote>
<p>可能这些看起来有些怪异（bizarre），但其实是很简单的。这其实是一种很常见的情况，只是有个不同的外在而已。想想当我们把x传递给一个函数的时候：<code>f(x)</code><br>因为我们传递给函数的是x的拷贝而不是x的本身，所以我们知道f不能修改x的值。如果我们想f能修改x的值，那么我们就必须给这个函数传递x的的地址了（也就是x的指针）: <code>f(&amp;x)</code></p>
<p>这样看起来就显得很简单很熟悉了，反射也是同样的运作方式的。如果我们也想让反射修改x的话，我们也必须给反射库(reflection library)一个我们想修改的值得指针。</p>
<p>让我们这操作一下试试。首先我们像往常一样初始化x，然后创建一个指向x的反射变量p：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="typename">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x) <span class="comment">// <span class="doctag">Note</span>: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">"type of p:"</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">"settability of p:"</span>, p.CanSet())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	type of p: *float64</span></span><br><span class="line">			settability of p: <span class="constant">false</span></span><br></pre></td></tr></table></figure>
<p>p这个反射是不可设置的，但是p也也不是我想设置的数据，我们要设置的实际是*p。想要得到p所指向的数据，我们使用Value的Elem方法。这个方法可以通过指针间接访问数据，并且保存在反射Value的变量v中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v := p.Elem()</span><br><span class="line">fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	settability of v: true</span></span><br></pre></td></tr></table></figure>
<p>既然v代表的是x，我们终于可以使用v.SetFloat修改x的值了：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br><span class="line">fmt.Println(v.Interface())</span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	7.1</span></span><br><span class="line">			<span class="number">7.1</span></span><br></pre></td></tr></table></figure></p>
<p>尽管反射执行着语言的功能，通过反射中Type和Values可以掩盖住具体的细节，但是可能还是难以去理解。你只需要记住了，Values需要一个数据的地址才能修改反射所代表的数据。</p>
<h2 id="结构体(Structs)">结构体(Structs)</h2><p>在我们之前的例子里，v并不是指针本身，它只是指针的派生而已。这种方法适用于用反射来修改结构体的域(field)。只要我们有这个结构体的体质，我们就能修改这个结构体的域。</p>
<p>这里有一个简单额例子来分析一下一个结构体变量t。因为我们待会要修改这个结构体，所以我们先用结构体的指针创建反射对象。我们用typeOf保存它的类型，用直接的方法（? straightforward method calls）迭代出所有的域【参考反射包获取更多的细节】。注意我们这里导出了结构体域的名字，但是域本身还是reflect.Value对象的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="typename">int</span></span><br><span class="line">    B <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">typeOfT := s.Type()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">    f := s.Field(i)</span><br><span class="line">    fmt.Printf(<span class="string">"%d: %s %s = %v\n"</span>, i,</span><br><span class="line">        typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	0: A int = 23</span></span><br><span class="line">			<span class="number">1</span>: B <span class="typename">string</span> = skidoo</span><br></pre></td></tr></table></figure>
<p>需要注意的是我们这里使用的可设置性（? there’s one more point about settability introduced in passing here）：这里把T的域名（field name）导出来，是因为一个结构体只有导出的域才能设置。</p>
<p>因为s中保存着一个可设置的反射对象，所以我们可以修改结构体的域：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.Field(<span class="number">0</span>).SetInt(<span class="number">77</span>)</span><br><span class="line">s.Field(<span class="number">1</span>).SetString(<span class="string">"Sunset Strip"</span>)</span><br><span class="line">fmt.Println(<span class="string">"t is now"</span>, t)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:	is now &#123;77 Sunset Strip&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果你把程序改成s是由t创建的而不是&amp;t，那么在你调用SetInt和SetString时程序就报错，因为此时t的域是不可修改的。</p>
<h2 id="小结（conclusion）">小结（conclusion）</h2><p>反射的规则：</p>
<ol>
<li>由接口到反射变量的反射</li>
<li>由反射对象到接口的反射</li>
<li>要修改一个反射对象，value必须是可设置的</li>
</ol>
<p>一旦说你了解了这些规则，尽管难以理解，但是Go会变的更容易使用。这是一个强大的工具，在使用的时候要注意，不是绝对必要的时候不要使用。</p>
<p>关于反射我们还有很多没有涉及——在channels中的发送和接收、分配内存、使用slice和map、调用方法和函数——但是这篇文章内容已经足够多了。我们会在后面文章里涉及这些内容中的部分。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/10/14/object-c/uibutton/">
                UIButton详解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-10-14
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/ios/">ios</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/10/14/object-c/uibutton/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/14/object-c/uibutton/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="创建">创建</h2><ol>
<li><p><strong>常规的 initWithFrame</strong><br><code>UIButton *btn1 = [[UIButton alloc]initWithFrame:CGRectMake(10, 10, 80, 44)];</code><br>对代码创建View（UIControl继承自UIView，所以也是view）不甚了解的请参看：《有关View的几个基础知识点》</p>
</li>
<li><p><strong>UIButton 的一个类方法（也可以说是静态方法）buttonWithType</strong><br><code>UIButton *btn2 = [UIButton buttonWithType:UIButtonTypeRoundedRect];</code><br>风格有如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;  </span><br><span class="line">    <span class="built_in">UIButtonTypeCustom</span> = <span class="number">0</span>,           <span class="comment">// 自定义，无风格  </span></span><br><span class="line">    <span class="built_in">UIButtonTypeRoundedRect</span>,        <span class="comment">// 白色圆角矩形，类似偏好设置表格单元或者地址簿卡片  </span></span><br><span class="line">    <span class="built_in">UIButtonTypeDetailDisclosure</span>,<span class="comment">//蓝色的披露按钮，可放在任何文字旁  </span></span><br><span class="line">    <span class="built_in">UIButtonTypeInfoLight</span>,<span class="comment">//微件(widget)使用的小圆圈信息按钮，可以放在任何文字旁  </span></span><br><span class="line">    <span class="built_in">UIButtonTypeInfoDark</span>,<span class="comment">//白色背景下使用的深色圆圈信息按钮  </span></span><br><span class="line">    <span class="built_in">UIButtonTypeContactAdd</span>,<span class="comment">//蓝色加号(+)按钮，可以放在任何文字旁  </span></span><br><span class="line">&#125; <span class="built_in">UIButtonType</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="设置属性">设置属性</h2><ul>
<li><p><strong>Frame属性</strong><br>第2种方法创建按钮后你可以给按钮的frame属性赋值，用一个CGRect结构设置他的位置和大小.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> btn2Frame = <span class="built_in">CGRectMake</span>(<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">60.0</span>, <span class="number">44.0</span>);  </span><br><span class="line">btn2<span class="variable">.frame</span> =btn2Frame;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>属性</strong><br>对于任何特定状态下的按钮，都可以设定该按钮该状态下的按钮标题。用setTitle 方法 设置即可：<br><code>[btn1 setTitle:@&quot;BTN1&quot; forState:UIControlStateNormal];</code><br>你也可以为按钮的某一状态设置为图。用 setImage 即可：<br><code>[btn2 setImage:[UIImage imageNamed:@&quot;pic&quot;] forState:UIControlStateNormal];</code><br>此外，你还可以为每种按钮状态设置标题的颜色和阴影，以及按钮的背景。方法 setTitleColor 和 setTitleShadowColor 都需要一个UIColor对象做参数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[btn1 setTitleColor:[<span class="built_in">UIColor</span> redColor] forState:<span class="built_in">UIControlStateNormal</span>];			<span class="comment">//设置标题颜色  </span></span><br><span class="line">[btn1 setTitleShadowColor:[<span class="built_in">UIColor</span> grayColor] forState:<span class="built_in">UIControlStateNormal</span> ];	<span class="comment">//阴影  </span></span><br><span class="line">[btn1 setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"PIC"</span>] forState:<span class="built_in">UIControlStateHighlighted</span>];	<span class="comment">//背景图像</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面几个方法都提到 共同的参数 forState . 这个参数决定了标题、图像或其他属性将在何种状态下显现。你可以编程令按钮在那个状态变化<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;  </span><br><span class="line">    <span class="built_in">UIControlStateNormal</span>       = <span class="number">0</span>,				<span class="comment">//常态                       </span></span><br><span class="line">    <span class="built_in">UIControlStateHighlighted</span>  = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,		<span class="comment">//高亮  </span></span><br><span class="line">    <span class="built_in">UIControlStateDisabled</span>     = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,		<span class="comment">//禁用  </span></span><br><span class="line">    <span class="built_in">UIControlStateSelected</span>     = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,		<span class="comment">// 选中  </span></span><br><span class="line">    <span class="built_in">UIControlStateApplication</span>  = <span class="number">0x00FF0000</span>,	<span class="comment">// 当应用程序标志使用时  </span></span><br><span class="line">    <span class="built_in">UIControlStateReserved</span>     = <span class="number">0xFF000000</span>		<span class="comment">// 为内部框架预留的  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">UIControlState</span>;</span><br></pre></td></tr></table></figure></p>
<p>你只要掌握前四种状态就好了。<br>当按钮高亮或者禁用，UIButton 类可以调整自己的外观，下面几个属性可以让你按照需要对按钮的外观进行微调：<br><strong>adjustsImageWhenHighlighted</strong><br>默认情况下，在按钮被禁用时，图像会被画的颜色深一些。要禁用此功能，请将这个属性设置为NO：<br><code>btn1.adjustsImageWhenHighlighted = NO;</code><br><strong>adjustsImageWhenDisabled</strong><br>默认情况下，按钮在被禁用时，图像会被画的颜色淡一些。要禁用此功能，请将这个属性设置为NO：<br><code>btn1.adjustsImageWhenDisabled = NO;</code><br><strong>showsTouchWhenHighlighted</strong><br>这个属性设置为YES，可令按钮在按下时发光。这可以用于信息按钮或者有些重要的按钮：<br><code>btn1.showsTouchWhenHighlighted = YES;</code></p>
<h2 id="显示控件">显示控件</h2><p>显示控件一如继往的简单：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:btn1];  </span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:btn2];</span><br></pre></td></tr></table></figure></p>
<h2 id="重写绘制行为">重写绘制行为</h2><p>你可以通过子类化按钮来定制属于你自己的按钮类。在子类化的时候你可以重载下面这些方法，这些方法返回CGRect结构，指明了按钮每一组成部分的边界。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">backgroundRectForBounds   <span class="comment">//指定背景边界  </span></span><br><span class="line">contentRectForBounds <span class="comment">// 指定内容边界  </span></span><br><span class="line">titleRectForContentRect    <span class="comment">// 指定文字标题边界  </span></span><br><span class="line">imageRectForContentRect     <span class="comment">//指定按钮图像边界  </span></span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)imageRectForContentRect:(<span class="built_in">CGRect</span>)bounds&#123;  </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">44</span>, <span class="number">44</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   注意：不要直接调用这些方法， 这些方法是你写给系统调用的。</p>
</blockquote>
<h2 id="添加动作">添加动作</h2><p>按钮是用来干嘛的？用来激发某个动作或事件的。那我们我们要为他添加一个动作，与 UIControl 里讲的一样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[btn1 addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnPressed:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];  </span><br><span class="line">-(<span class="keyword">void</span>)btnPressed:(<span class="keyword">id</span>)sender&#123;  </span><br><span class="line">	<span class="built_in">UIButton</span>* btn = (<span class="built_in">UIButton</span>*)sender;   </span><br><span class="line">	<span class="comment">//开始写你自己的动作  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/10/13/php/设计模式/">
                设计模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-10-13
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/php/">php</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/10/13/php/设计模式/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/13/php/设计模式/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="单例模式">单例模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>
<span class="comment">/**
 * 单例模式
 *
 */</span>
<span class="class"><span class="keyword">class</span> <span class="title">DbConn</span>
</span>{
       <span class="keyword">private</span> <span class="keyword">static</span> <span class="variable">$_instance</span> = <span class="keyword">null</span>;
       <span class="keyword">protected</span> <span class="keyword">static</span> <span class="variable">$_counter</span> = <span class="number">0</span>;
       <span class="keyword">protected</span> <span class="variable">$_db</span>;
       <span class="comment">//私有化构造函数，不允许外部创建实例</span>
       <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span>
       </span>{
              <span class="keyword">self</span>::<span class="variable">$_counter</span> += <span class="number">1</span>;
       }

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span>
       </span>{
              <span class="keyword">if</span> (<span class="keyword">self</span>::<span class="variable">$_instance</span> == <span class="keyword">null</span>)
              {
                     <span class="keyword">self</span>::<span class="variable">$_instance</span> = <span class="keyword">new</span> DbConn();
              }
              <span class="keyword">return</span> <span class="keyword">self</span>::<span class="variable">$_instance</span>;
       }

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span>
       </span>{
              <span class="keyword">echo</span> <span class="string">"connected: "</span>.(<span class="keyword">self</span>::<span class="variable">$_counter</span>).<span class="string">"n"</span>;
              <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_db;
       }
}
<span class="comment">/*
 * 不使用单例模式时，删除构造函数的private后再测试，第二次调用构造函数后，_counter变成2
*/</span>
<span class="comment">// $conn = new DbConn();</span>
<span class="comment">// $conn-&gt;connect();</span>
<span class="comment">// $conn = new DbConn();</span>
<span class="comment">// $conn-&gt;connect();</span>
<span class="comment">//使用单例模式后不能直接new对象，必须调用getInstance获取</span>
<span class="variable">$conn</span> = DbConn::getInstance();
<span class="variable">$db</span> = <span class="variable">$conn</span>-&gt;connect();
<span class="comment">//第二次调用是同一个实例，_counter还是1</span>
<span class="variable">$conn</span> = DbConn::getInstance();
<span class="variable">$db</span> = <span class="variable">$conn</span>-&gt;connect();
<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>特别说明：这里getInstance里有if判断然后再生成对象，在多线程语言里是会有并发问题的。例如java的解决方案有二个，给方法加上synchronized关键词变成同步，或者把_instanc的初始化提前放到类成员变量定义时，但是这2种方式php都不支持。不过因为php不支持多线程所以不需要考虑这个问题了。</li>
</ul>
<h2 id="工厂模式">工厂模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>
<span class="comment">/**
 *
 * 工厂模式
 *
 */</span>

<span class="comment">//抽象产品</span>
<span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>{
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span>; 
}
<span class="comment">//具体产品实现</span>
<span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"老师n"</span>;
    }
}
<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"学生n"</span>;
    }
}

<span class="comment">//简单工厂</span>
<span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>{
       <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">(<span class="variable">$type</span>)</span> </span>{
              <span class="variable">$person</span> = <span class="keyword">null</span>;
              <span class="keyword">if</span> (<span class="variable">$type</span> == <span class="string">'teacher'</span>) {
                     <span class="variable">$person</span> = <span class="keyword">new</span> Teacher();
              } <span class="keyword">elseif</span> (<span class="variable">$type</span> == <span class="string">'student'</span>) {
                     <span class="variable">$person</span> = <span class="keyword">new</span> Student();
              }
              <span class="keyword">return</span> <span class="variable">$person</span>;
       }
}

<span class="comment">//简单工厂调用</span>
<span class="class"><span class="keyword">class</span> <span class="title">SimpleClient</span> </span>{
       <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>{
              <span class="comment">// 如果不用工厂模式，则需要提前指定具体类</span>
              <span class="comment">// $person = new Teacher();</span>
              <span class="comment">// echo $person-&gt;getName();</span>
              <span class="comment">// $person = new Student();</span>
              <span class="comment">// echo $person-&gt;getName();</span>

              <span class="comment">// 用工厂模式，则不需要知道对象由什么类产生，交给工厂去决定</span>
              <span class="variable">$person</span> = SimpleFactory::getPerson(<span class="string">'teacher'</span>);
              <span class="keyword">echo</span> <span class="variable">$person</span>-&gt;getName();
              <span class="variable">$person</span> = SimpleFactory::getPerson(<span class="string">'student'</span>);
              <span class="keyword">echo</span> <span class="variable">$person</span>-&gt;getName();
       }
}


<span class="comment">//工厂方法</span>
<span class="class"><span class="keyword">interface</span> <span class="title">CommFactory</span> </span>{
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span></span>;
}
<span class="comment">//具体工厂实现</span>
<span class="class"><span class="keyword">class</span> <span class="title">StudentFactory</span> <span class="keyword">implements</span> <span class="title">CommFactory</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Student();
    }
}
<span class="class"><span class="keyword">class</span> <span class="title">TeacherFactory</span> <span class="keyword">implements</span> <span class="title">CommFactory</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Teacher();
    }
}

<span class="comment">//工厂方法调用</span>
<span class="class"><span class="keyword">class</span> <span class="title">CommClient</span> </span>{
    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>{
           <span class="variable">$factory</span> = <span class="keyword">new</span> TeacherFactory();
           <span class="keyword">echo</span> <span class="variable">$factory</span>-&gt;getPerson()-&gt;getName();
           <span class="variable">$factory</span> = <span class="keyword">new</span> StudentFactory();
           <span class="keyword">echo</span> <span class="variable">$factory</span>-&gt;getPerson()-&gt;getName();
    }
}



<span class="comment">//抽象工厂模式另一条产品线</span>
<span class="class"><span class="keyword">interface</span> <span class="title">Grade</span> </span>{
       <span class="function"><span class="keyword">function</span> <span class="title">getYear</span><span class="params">()</span></span>;
}
<span class="comment">//另一条产品线的具体产品</span>
<span class="class"><span class="keyword">class</span> <span class="title">Grade1</span> <span class="keyword">implements</span> <span class="title">Grade</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getYear</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="string">'2003级'</span>;
       }
}
<span class="class"><span class="keyword">class</span> <span class="title">Grade2</span> <span class="keyword">implements</span> <span class="title">Grade</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getYear</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="string">'2004级'</span>;
       }
}
<span class="comment">//抽象工厂</span>
<span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>{
       <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span></span>;
       <span class="function"><span class="keyword">function</span> <span class="title">getGrade</span><span class="params">()</span></span>;
}
<span class="comment">//具体工厂可以产生每个产品线的产品</span>
<span class="class"><span class="keyword">class</span> <span class="title">Grade1TeacherFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Teacher();
       }
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getGrade</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Grade1();
       }
}
<span class="class"><span class="keyword">class</span> <span class="title">Grade1StudentFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Student();
       }
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getGrade</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Grade1();
       }
}
<span class="class"><span class="keyword">class</span> <span class="title">Grade2TeacherFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Teacher();
       }
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getGrade</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Grade2();
       }
}
<span class="comment">//抽象工厂调用</span>
<span class="class"><span class="keyword">class</span> <span class="title">FactoryClient</span> </span>{
       <span class="function"><span class="keyword">function</span> <span class="title">printInfo</span><span class="params">(<span class="variable">$factory</span>)</span> </span>{
              <span class="keyword">echo</span> <span class="variable">$factory</span>-&gt;getGrade()-&gt;getYear().<span class="variable">$factory</span>-&gt;getPerson()-&gt;getName();
       }
       <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>{
              <span class="variable">$client</span> = <span class="keyword">new</span> FactoryClient();
              <span class="variable">$factory</span> = <span class="keyword">new</span> Grade1TeacherFactory();
              <span class="variable">$client</span>-&gt;printInfo(<span class="variable">$factory</span>);
              <span class="variable">$factory</span> = <span class="keyword">new</span> Grade1StudentFactory();
              <span class="variable">$client</span>-&gt;printInfo(<span class="variable">$factory</span>);
              <span class="variable">$factory</span> = <span class="keyword">new</span> Grade2TeacherFactory();
              <span class="variable">$client</span>-&gt;printInfo(<span class="variable">$factory</span>);
       }
}


<span class="comment">//简单工厂</span>
<span class="comment">//SimpleClient::main();</span>
<span class="comment">//工厂方法</span>
<span class="comment">//CommClient::main();</span>
<span class="comment">//抽象工厂</span>
FactoryClient::main();

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>三种工厂的区别是，抽象工厂由多条产品线，而工厂方法只有一条产品线，是抽象工厂的简化。而工厂方法和简单工厂相对，大家初看起来好像工厂方法增加了许多代码但是实现的功能和简单工厂一样。但本质是，简单工厂并未严格遵循设计模式的开闭原则，当需要增加新产品时也需要修改工厂代码。但是工厂方法则严格遵守开闭原则，模式只负责抽象工厂接口，具体工厂交给客户去扩展。在分工时，核心工程师负责抽象工厂和抽象产品的定义，业务工程师负责具体工厂和具体产品的实现。只要抽象层设计的好，框架就是非常稳定的。</li>
</ul>
<h2 id="创建者模式">创建者模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>
<span class="comment">/**
 *
 * 创建者模式
 *
 */</span>

<span class="comment">//购物车</span>
<span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>{
       <span class="comment">//选中的商品</span>
    <span class="keyword">private</span> <span class="variable">$_goods</span> = <span class="keyword">array</span>();
    <span class="comment">//使用的优惠券</span>
    <span class="keyword">private</span> <span class="variable">$_tickets</span> = <span class="keyword">array</span>();

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addGoods</span><span class="params">(<span class="variable">$goods</span>)</span> </span>{
              <span class="variable">$this</span>-&gt;_goods[] = <span class="variable">$goods</span>;
       }

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addTicket</span><span class="params">(<span class="variable">$ticket</span>)</span> </span>{
           <span class="variable">$this</span>-&gt;_tickets[] = <span class="variable">$ticket</span>;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">printInfo</span><span class="params">()</span> </span>{
           printf(<span class="string">"goods:%s, tickets:%sn"</span>, implode(<span class="string">','</span>, <span class="variable">$this</span>-&gt;_goods), implode(<span class="string">','</span>, <span class="variable">$this</span>-&gt;_tickets));
    }
}

<span class="comment">//假如我们要还原购物车的东西，比如用户关闭浏览器后再打开时会根据cookie还原</span>
<span class="variable">$data</span> = <span class="keyword">array</span>(
       <span class="string">'goods'</span> =&gt; <span class="keyword">array</span>(<span class="string">'衣服'</span>, <span class="string">'鞋子'</span>),
       <span class="string">'tickets'</span> =&gt; <span class="keyword">array</span>(<span class="string">'减10'</span>),
);

<span class="comment">//如果不使用创建者模式，则需要业务类里一步步还原购物车</span>
<span class="comment">// $cart = new ShoppingCart();</span>
<span class="comment">// foreach ($data['goods'] as $goods) {</span>
<span class="comment">//   $cart-&gt;addGoods($goods);</span>
<span class="comment">// }</span>
<span class="comment">// foreach ($data['tickets'] as $ticket) {</span>
<span class="comment">//   $cart-&gt;addTicket($ticket);</span>
<span class="comment">// }</span>
<span class="comment">// $cart-&gt;printInfo();</span>
<span class="comment">// exit;</span>


<span class="comment">//我们提供创建者类来封装购物车的数据组装</span>
<span class="class"><span class="keyword">class</span> <span class="title">CardBuilder</span> </span>{
       <span class="keyword">private</span> <span class="variable">$_card</span>;
       <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$card</span>)</span> </span>{
              <span class="variable">$this</span>-&gt;_card = <span class="variable">$card</span>;
       }
       <span class="function"><span class="keyword">function</span> <span class="title">build</span><span class="params">(<span class="variable">$data</span>)</span> </span>{
              <span class="keyword">foreach</span> (<span class="variable">$data</span>[<span class="string">'goods'</span>] <span class="keyword">as</span> <span class="variable">$goods</span>) {
                     <span class="variable">$this</span>-&gt;_card-&gt;addGoods(<span class="variable">$goods</span>);
              }
              <span class="keyword">foreach</span> (<span class="variable">$data</span>[<span class="string">'tickets'</span>] <span class="keyword">as</span> <span class="variable">$ticket</span>) {
                     <span class="variable">$this</span>-&gt;_card-&gt;addTicket(<span class="variable">$ticket</span>);
              }
       }
       <span class="function"><span class="keyword">function</span> <span class="title">getCrad</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_card;
       }
}

<span class="variable">$cart</span> = <span class="keyword">new</span> ShoppingCart();
<span class="variable">$builder</span> = <span class="keyword">new</span> CardBuilder(<span class="variable">$cart</span>);
<span class="variable">$builder</span>-&gt;build(<span class="variable">$data</span>);
<span class="keyword">echo</span> <span class="string">"after builder:n"</span>;
<span class="variable">$cart</span>-&gt;printInfo();

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>可以看出，使用创建者模式对内部数据复杂的对象封装数据组装过程后，对外接口就会非常简单和规范，增加修改新数据项也不会对外部造成任何影响。</li>
</ul>
<h2 id="原型模式">原型模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>
<span class="comment">/**
 *
 * 原型模式
 */</span>

<span class="comment">//声明一个克隆自身的接口</span>
<span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">()</span></span>; 
}   

<span class="comment">//产品要实现克隆自身的操作</span>
<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>{
       <span class="comment">//简单起见，这里没有使用get set</span>
    <span class="keyword">public</span> <span class="variable">$school</span>;
    <span class="keyword">public</span> <span class="variable">$major</span>;
       <span class="keyword">public</span> <span class="variable">$name</span>;

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$school</span>, <span class="variable">$major</span>, <span class="variable">$name</span>)</span> </span>{
              <span class="variable">$this</span>-&gt;school = <span class="variable">$school</span>;
              <span class="variable">$this</span>-&gt;major = <span class="variable">$major</span>;
              <span class="variable">$this</span>-&gt;name = <span class="variable">$name</span>;
       }

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">printInfo</span><span class="params">()</span> </span>{
              printf(<span class="string">"%s,%s,%sn"</span>, <span class="variable">$this</span>-&gt;school, <span class="variable">$this</span>-&gt;major, <span class="variable">$this</span>-&gt;name);
       }

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">()</span> </span>{
           <span class="keyword">return</span> <span class="keyword">clone</span> <span class="variable">$this</span>;
    }
}

<span class="variable">$stu1</span> = <span class="keyword">new</span> Student(<span class="string">'清华大学'</span>, <span class="string">'计算机'</span>, <span class="string">'张三'</span>);
<span class="variable">$stu1</span>-&gt;printInfo();

<span class="variable">$stu2</span> = <span class="variable">$stu1</span>-&gt;copy();
<span class="variable">$stu2</span>-&gt;name = <span class="string">'李四'</span>;
<span class="variable">$stu2</span>-&gt;printInfo();

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>这里可以看到，如果类的成员变量非常多，如果由外部创建多个新对象再一个个赋值，则效率不高代码冗余也容易出错，通过原型拷贝复制自身再进行微小修改就是另一个新对象了。</li>
</ul>
<h2 id="适配器模式">适配器模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>  
<span class="comment">/**  
 *  
 * 适配器模式  
 *  
 */</span>

<span class="comment">//老的代码   </span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{  
    <span class="keyword">private</span> <span class="variable">$name</span>;  
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$name</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;name = <span class="variable">$name</span>;  
    }  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{  
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;name;  
    }  
}  

<span class="comment">//新代码，开放平台标准接口  </span>
<span class="class"><span class="keyword">interface</span> <span class="title">UserInterface</span> </span>{  
    <span class="function"><span class="keyword">function</span> <span class="title">getUserName</span><span class="params">()</span></span>;  
}  
<span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">UserInterface</span> </span>{  
    <span class="keyword">protected</span> <span class="variable">$user</span>;  
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$user</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;user = <span class="variable">$user</span>;  
    }  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserName</span><span class="params">()</span> </span>{  
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;user-&gt;getName();  
    }  
}  

<span class="variable">$olduser</span> = <span class="keyword">new</span> User(<span class="string">'张三'</span>);  
<span class="keyword">echo</span> <span class="variable">$olduser</span>-&gt;getName().<span class="string">"n"</span>;  
<span class="variable">$newuser</span> = <span class="keyword">new</span> UserInfo(<span class="variable">$olduser</span>);  
<span class="keyword">echo</span> <span class="variable">$newuser</span>-&gt;getUserName().<span class="string">"n"</span>;  

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>注意点：这里的新接口使用了组合方式，UserInfo内部有一个成员变量保存老接口User对象，模块之间是松耦合的，这种结构其实就是组合模式。不要使用继承，虽然UserInfo继承User也能达到同样的目的，但是耦合度高，相互产生影响。</li>
</ul>
<h2 id="桥接模式">桥接模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 桥接模式   
 *   
 */</span>

<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{   
    <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">getJob</span><span class="params">()</span></span>;   
}   

<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJob</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'学生'</span>;   
    }   
}   

<span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJob</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'老师'</span>;   
    }   
}   

<span class="class"><span class="keyword">class</span> <span class="title">BridgeObj</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_person</span>;   

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setPerson</span><span class="params">(<span class="variable">$person</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;_person = <span class="variable">$person</span>;   
    }   

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJob</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_person-&gt;getJob();   
    }   
}   

<span class="variable">$obj</span> = <span class="keyword">new</span> BridgeObj();   
<span class="variable">$obj</span>-&gt;setPerson(<span class="keyword">new</span> Student());   
printf(<span class="string">"本次桥接对象：%sn"</span>, <span class="variable">$obj</span>-&gt;getJob());   
<span class="variable">$obj</span>-&gt;setPerson(<span class="keyword">new</span> Teacher());   
printf(<span class="string">"本次桥接对象：%sn"</span>, <span class="variable">$obj</span>-&gt;getJob());   


<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>将抽象部分与它的实现部分分离，使它们都可以独立变化</li>
</ul>
<h2 id="装饰模式">装饰模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 装饰模式   
 *    
 */</span>

<span class="comment">//产品   </span>
<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{   
    <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">getPermission</span><span class="params">()</span></span>;   
}   
<span class="comment">//被装饰者   </span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPermission</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'公开文档'</span>;   
    }   
}   
<span class="comment">//装饰类   </span>
<span class="class"><span class="keyword">class</span> <span class="title">PermUser</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_user</span>;   
    <span class="keyword">protected</span> <span class="variable">$_special</span> = <span class="string">''</span>;   
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$user</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;_user = <span class="variable">$user</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPermission</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_user-&gt;getPermission() . <span class="variable">$this</span>-&gt;_special;   
    }   
}   
<span class="comment">//装饰类产品   </span>
<span class="class"><span class="keyword">class</span> <span class="title">JavaUser</span> <span class="keyword">extends</span> <span class="title">PermUser</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_special</span> = <span class="string">' java程序'</span>;   
}   
<span class="class"><span class="keyword">class</span> <span class="title">CPlusUser</span> <span class="keyword">extends</span> <span class="title">PermUser</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_special</span> = <span class="string">' c++程序'</span>;   
}   


<span class="variable">$user</span> = <span class="keyword">new</span> User();   
printf(<span class="string">"permission：%sn"</span>, <span class="variable">$user</span>-&gt;getPermission());   
<span class="variable">$user</span> = <span class="keyword">new</span> JavaUser(<span class="variable">$user</span>);   
printf(<span class="string">"permission：%sn"</span>, <span class="variable">$user</span>-&gt;getPermission());   
<span class="variable">$user</span> = <span class="keyword">new</span> CPlusUser(<span class="variable">$user</span>);   
printf(<span class="string">"permission：%sn"</span>, <span class="variable">$user</span>-&gt;getPermission());   


<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>大家想想装饰和继承的区别在哪？</li>
<li>如果是上面的例子，如果用继承，是CPlusUser继承JavaUser还是反过来呢？谁也不知道最终使用者需要哪一种。</li>
<li>在多层关系的情况下，装饰是和顺序无关并且随时增加装饰，而继承只能是特定的顺序，所以装饰模式会更加的灵活。</li>
</ul>
<h2 id="组合模式">组合模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 组合模式   
 *    
 */</span>

<span class="comment">//继承模式   </span>

<span class="class"><span class="keyword">class</span> <span class="title">UserBaseInfo</span> </span>{   
    <span class="keyword">private</span> <span class="variable">$name</span>;   

    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$name</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;name = <span class="variable">$name</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;name;   
    }   
}   
<span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">UserBaseInfo</span> </span>{   
    <span class="keyword">private</span> <span class="variable">$login</span> = <span class="keyword">false</span>;   

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setLogin</span><span class="params">(<span class="variable">$islogin</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;login = <span class="variable">$islogin</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isLogin</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;login;   
    }   
}   

<span class="variable">$user</span> = <span class="keyword">new</span> User(<span class="string">'张三'</span>);   
<span class="variable">$user</span>-&gt;setLogin(<span class="keyword">true</span>);   
<span class="keyword">if</span> (<span class="variable">$user</span>-&gt;isLogin()) {   
    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;getName().<span class="string">"已经登录了n"</span>;   
} <span class="keyword">else</span> {   
    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;getName().<span class="string">"还没有登录n"</span>;   
}   


<span class="comment">//组合模式   </span>

<span class="class"><span class="keyword">class</span> <span class="title">LoginInfo</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$user</span>;   
    <span class="keyword">protected</span> <span class="variable">$login</span> = <span class="keyword">false</span>;   

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setLogin</span><span class="params">(<span class="variable">$user</span>, <span class="variable">$isLogin</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;user = <span class="variable">$user</span>;   
        <span class="variable">$this</span>-&gt;login = <span class="variable">$isLogin</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isLogin</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;login;   
    }   
}   

<span class="variable">$user</span> = <span class="keyword">new</span> User(<span class="string">'张三'</span>);   
<span class="variable">$login</span> = <span class="keyword">new</span> LoginInfo();   
<span class="variable">$login</span>-&gt;setLogin(<span class="variable">$user</span>, <span class="keyword">true</span>);   
<span class="keyword">if</span> (<span class="variable">$login</span>-&gt;isLogin()) {   
    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;getName().<span class="string">"已经登录了n"</span>;   
} <span class="keyword">else</span> {   
    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;getName().<span class="string">"还没有登录n"</span>;   
}   

<span class="comment">//部分可以更换，用继承则不行   </span>
<span class="class"><span class="keyword">class</span> <span class="title">Admin</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$level</span>;   
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$level</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;level = <span class="variable">$level</span>;   
    }   
    <span class="function"><span class="keyword">function</span> <span class="title">getLevel</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;level;   
    }   
}   
<span class="variable">$admin</span> = <span class="keyword">new</span> Admin(<span class="number">1</span>);   
<span class="variable">$login</span>-&gt;setLogin(<span class="variable">$admin</span>, <span class="keyword">true</span>);   
<span class="keyword">if</span> (<span class="variable">$login</span>-&gt;isLogin()) {   
    printf(<span class="string">"级别为 %d 的管理员已经登录了n"</span>, <span class="variable">$admin</span>-&gt;getLevel());   
} <span class="keyword">else</span> {   
    printf(<span class="string">"级别为 %d 的管理员还没有登录n"</span>, <span class="variable">$admin</span>-&gt;getLevel());   
}   

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>上面的例子分别展示了使用继承和组合来处理新功能，在简单的情况下看似区别不大，但在项目后期越来越复杂的时候组合模式的优势就越来越明显了。</li>
<li>例如上面的登录信息，如果要增加登录次数、最后登录时间、登录ip等信息，登录本身就会变成一个比较复杂的对象。如果以后有新的需求比如好友信息、用户的访问信息等，再要继承的话，用户类就会变得非常庞大，难免各父类之间没有冲突的变量和方法，而外部访问用户类的众多方法也变得很费劲。采用组合模式后，一个类负责一个角色，功能区分非常明显，扩展方便。</li>
</ul>
<h2 id="外观模式">外观模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 外观模式，也叫门面模式   
 *    
 */</span>


<span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPlus</span><span class="params">()</span> </span>{   
        printf(<span class="string">"plus: %sn"</span>, (<span class="number">1</span> + <span class="number">2</span> == <span class="number">3</span> ? <span class="string">'true'</span> : <span class="string">'false'</span>));   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testMinus</span><span class="params">()</span> </span>{   
        printf(<span class="string">"minus: %sn"</span>, (<span class="number">3</span> - <span class="number">2</span> == <span class="number">2</span> ? <span class="string">'true'</span> : <span class="string">'false'</span>));   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testTimes</span><span class="params">()</span> </span>{   
        printf(<span class="string">"times: %sn"</span>, (<span class="number">2</span> * <span class="number">3</span> == <span class="number">6</span> ? <span class="string">'true'</span> : <span class="string">'false'</span>));   
    }   
}   

<span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_operation</span>;   
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{   
        <span class="variable">$this</span>-&gt;_operation = <span class="keyword">new</span> Operation();   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testAll</span><span class="params">()</span> </span>{   
        <span class="variable">$this</span>-&gt;_operation-&gt;testPlus();   
        <span class="variable">$this</span>-&gt;_operation-&gt;testMinus();   
        <span class="variable">$this</span>-&gt;_operation-&gt;testTimes();   
    }   
}   

<span class="comment">//测试用例，测试全部接口   </span>
<span class="variable">$tester</span> = <span class="keyword">new</span> Tester();   
<span class="variable">$tester</span>-&gt;testAll();   


<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>门面模式估计大家在实际代码中都已经使用到了，接口较多时把相似功能的接口封装成一个接口供外部调用，这就是门面模式。</li>
</ul>
<h2 id="单纯享元模式">单纯享元模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>  


<span class="comment">/** 
 * 抽象享元角色 
 */</span>  
<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>{  

    <span class="comment">/** 
     * 示意性方法 
     * <span class="doctag">@param</span> string $state 外部状态 
     */</span>  
    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span></span>;  
}  

<span class="comment">/** 
 * 具体享元角色 
 */</span>  
<span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_intrinsicState</span> = <span class="keyword">null</span>;  

    <span class="comment">/** 
     * 构造方法 
     * <span class="doctag">@param</span> string $state  内部状态 
     */</span>  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;_intrinsicState = <span class="variable">$state</span>;  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">echo</span> <span class="string">'ConcreteFlyweight operation, Intrinsic State = '</span> . <span class="variable">$this</span>-&gt;_intrinsicState  
        . <span class="string">' Extrinsic State = '</span> . <span class="variable">$state</span> . <span class="string">'&lt;br /&gt;'</span>;  
    }  

}  


<span class="comment">/** 
 * 享元工厂角色 
 */</span>  
<span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_flyweights</span>;  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{  
        <span class="variable">$this</span>-&gt;_flyweights = <span class="keyword">array</span>();  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFlyweigth</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>])) {  
            <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>];  
        } <span class="keyword">else</span> {  
            <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>] = <span class="keyword">new</span> ConcreteFlyweight(<span class="variable">$state</span>);  
        }  
    }  

}  

<span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>{  
    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> <span class="params">()</span></span>{  
        <span class="variable">$flyweightFactory</span> = <span class="keyword">new</span> FlyweightFactory();  
        <span class="variable">$flyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="string">'state A'</span>);  
        <span class="variable">$flyweight</span>-&gt;operation(<span class="string">'other state A'</span>);  

        <span class="variable">$flyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="string">'state B'</span>);  
        <span class="variable">$flyweight</span>-&gt;operation(<span class="string">'other state B'</span>);  

    }  
}  



<span class="preprocessor">?&gt;</span>
</code></pre>
<h2 id="复合享元模式">复合享元模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>  

<span class="comment">/** 
 * 复合享元模式 
 *  
 */</span>  

<span class="comment">/** 
 * 抽象享元角色 
 */</span>  
<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>{  

    <span class="comment">/** 
     * 示意性方法 
     * <span class="doctag">@param</span> string $state 外部状态 
     */</span>  
    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span></span>;  
}  

<span class="comment">/** 
 * 具体享元角色 
 */</span>  
<span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_intrinsicState</span> = <span class="keyword">null</span>;  

    <span class="comment">/** 
     * 构造方法 
     * <span class="doctag">@param</span> string $state  内部状态 
     */</span>  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;_intrinsicState = <span class="variable">$state</span>;  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">echo</span> <span class="string">'ConcreteFlyweight operation, Intrinsic State = '</span> . <span class="variable">$this</span>-&gt;_intrinsicState  
        . <span class="string">' Extrinsic State = '</span> . <span class="variable">$state</span> . <span class="string">'&lt;br /&gt;'</span>;  
    }  

}  

<span class="comment">/** 
 * 不共享的具体享元，客户端直接调用 
 */</span>  
<span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_flyweights</span>;  

    <span class="comment">/** 
     * 构造方法 
     * <span class="doctag">@param</span> string $state  内部状态 
     */</span>  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{  
        <span class="variable">$this</span>-&gt;_flyweights = <span class="keyword">array</span>();  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">foreach</span> (<span class="variable">$this</span>-&gt;_flyweights <span class="keyword">as</span> <span class="variable">$flyweight</span>) {  
            <span class="variable">$flyweight</span>-&gt;operation(<span class="variable">$state</span>);  
        }  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(<span class="variable">$state</span>, Flyweight <span class="variable">$flyweight</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>] = <span class="variable">$flyweight</span>;  
    }  

}  

<span class="comment">/** 
* 享元工厂角色 
*/</span>  
<span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_flyweights</span>;  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{  
        <span class="variable">$this</span>-&gt;_flyweights = <span class="keyword">array</span>();  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFlyweigth</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">if</span> (is_array(<span class="variable">$state</span>)) { <span class="comment">//  复合模式  </span>
            <span class="variable">$uFlyweight</span> = <span class="keyword">new</span> UnsharedConcreteFlyweight();  

            <span class="keyword">foreach</span> (<span class="variable">$state</span> <span class="keyword">as</span> <span class="variable">$row</span>) {  
                <span class="variable">$uFlyweight</span>-&gt;add(<span class="variable">$row</span>, <span class="variable">$this</span>-&gt;getFlyweigth(<span class="variable">$row</span>));  
            }  
            <span class="keyword">return</span> <span class="variable">$uFlyweight</span>;  
        } <span class="keyword">else</span> <span class="keyword">if</span> (is_string(<span class="variable">$state</span>)) {  
            <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>])) {  
                <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>];  
            } <span class="keyword">else</span> {  
                <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>] = <span class="keyword">new</span> ConcreteFlyweight(<span class="variable">$state</span>);  
            }  
        } <span class="keyword">else</span> {  
            <span class="keyword">return</span> <span class="keyword">null</span>;  
        }  
    }  

}  

<span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>{  
    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> <span class="params">()</span></span>{  
        <span class="variable">$flyweightFactory</span> = <span class="keyword">new</span> FlyweightFactory();  
        <span class="variable">$flyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="string">'state A'</span>);  
        <span class="variable">$flyweight</span>-&gt;operation(<span class="string">'other state A'</span>);  

        <span class="variable">$flyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="string">'state B'</span>);  
        <span class="variable">$flyweight</span>-&gt;operation(<span class="string">'other state B'</span>);  

        <span class="comment">/* 复合对象*/</span>  
        <span class="variable">$uflyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="keyword">array</span>(<span class="string">'state A'</span>, <span class="string">'state B'</span>));  
        <span class="variable">$uflyweight</span>-&gt;operation(<span class="string">'other state A'</span>);  

    }  
}  


<span class="preprocessor">?&gt;</span>
</code></pre>
<h2 id="代理模式">代理模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 代理模式   
 *   
 */</span>

<span class="comment">//内部对象   </span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'张三'</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getType</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'付费用户'</span>;   
    }   
}   

<span class="comment">//代理接口定义，例如开放平台   </span>
<span class="class"><span class="keyword">interface</span> <span class="title">UserInterface</span> </span>{   
    <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span>;   
}   
<span class="comment">//代理对象   </span>
<span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">UserInterface</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_user</span>;   
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{   
        <span class="variable">$this</span>-&gt;_user = <span class="keyword">new</span> User();   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_user-&gt;getName();   
    }   
}   

<span class="comment">//内部调用   </span>
<span class="variable">$user</span> = <span class="keyword">new</span> User();   
printf(<span class="string">"user name：%sn"</span>, <span class="variable">$user</span>-&gt;getName());   
printf(<span class="string">"user type：%sn"</span>, <span class="variable">$user</span>-&gt;getType());   
<span class="comment">//外部调用   </span>
<span class="comment">// $user = new UserProxy();   </span>
<span class="comment">// printf("user name：%sn", $user-&gt;getName());   </span>
<span class="comment">// printf("user type：%sn", $user-&gt;getType()); //不能访问，及时知道内部对象有这个方法   </span>

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>代理模式、适配器模式、门面模式、装饰模式的区别</li>
<li>相同之处：都封装一个内部对象，调用内部对象的方法</li>
<li>不同之处：各自有各自的特性和应用场景，不能相互替代。所以用的时候要仔细分析用那种合适。</li>
</ul>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/19/self/sdk接入文档/">
                sdk接入文档
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-19
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/19/self/sdk接入文档/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/19/self/sdk接入文档/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="接入sdk">接入sdk</h1><p><img src="/img/sdk接入文档/sdk_01.jpg" alt="加入类库"></p>
<p><img src="/img/sdk接入文档/sdk_02.jpg" alt="添加framework"></p>
<p><img src="/img/sdk接入文档/sdk_03.jpg" alt="增加编译参数"></p>
<p><img src="/img/sdk接入文档/sdk_04.jpg" alt="修改参数"></p>
<p><img src="/img/sdk接入文档/sdk_05.jpg" alt="初始化"></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/19/php/http头信息/">
                http头信息
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-19
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/php/">php</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/19/php/http头信息/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/19/php/http头信息/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="常见头信息">常见头信息</h1><ol>
<li><p>Accept：告诉服务器，客户端可以接受的资源类型，可以是一个类型，也可以是多个类型，多个类型间用逗号分隔开<br>特殊的<em>/</em>表示什么类型都可以;q表示希望返回资源的级别，没有的话默认是1，显示写的话通常在类型后用分号分开，往往是一个键值对的形式，如q=0.8。通常服务器会响应一个Content-type的响应头信息。</p>
</li>
<li><p>Accept-Encoding:告诉服务器，客户端支持什么样的压缩算法，可以为一个值或多个值，用逗号分开，常用的压缩算法有gzip。服务器在收到这个字段后，会检查服务器是否支持这个算法，如果支持，就会在发回响应信息前，对资源进行压缩，这样可以减小响应资源的大小。通常服务器会响应一个Content-Encoding:gzip的响应头信息。</p>
</li>
<li><p>Accept-Language:告诉服务器，客户端希望服务器返回的语言格式，对于支持国际话的服务端来说，这个字段很重要，可以通过这个字段，返回不同语言的资源</p>
</li>
<li><p>Cache-Control：这个值告诉服务器客户端希望的缓存策略，如果出现在客户端的请求头中，值往往是max-age=0,告诉服务器，客户端是不缓存服务器资源的</p>
</li>
<li><p>Connection：客户端发送的值往往是keep-alive，这个值告诉服务器自己打开的是一个长tcp连接，服务器接受到这个值后，如果接受这个长连接，就会返回Connection：keep-alive，这样当客户端再有请求发送时，就会重用这个tcp连接；如果不接受长连接就会返回Connection：close。正确的理解keep-alive必须对tcp/ip协议有一定的了解</p>
</li>
<li><p>Cookie：这个值是服务器存储在客户端的数据，cookie是一组键值对，用；分隔开。Cookie有很多重要的知识点，对web开发人员来说极其重要，以后会单独来说明。</p>
</li>
<li><p>Host：这个值对应的是服务器域名或者ip地址。</p>
</li>
<li><p>User-Agent:这个值描述了客户端的详细信息。如果你想写一个简单的爬虫软件，没有这个字段的话，是会被一些服务器拦截的（曾经爬网易的时候就遇到过这个问题）。</p>
</li>
</ol>
<p><strong>上面的这些是chrome请求oschina时的请求头信息，HTTP协议规定的请求头当然远远不止上面说的这些，下面我们再说一些比较常用的请求头：</strong></p>
<ol>
<li><p>Referer:当点击某个网页的的a标签时或者表单提交时，会带上这个值，告诉服务器，这个请求时从哪个页面来的，这样服务器通过这个值就可以统计流量都是从哪里来的，一些广告服务提供商就是靠这个值来收费的。</p>
</li>
<li><p>if-modified-since:这个值是服务器上次响应时请求时发送给客户端的date时间，如果服务器看到这个字段，如果在这段时间没有修改过资源，服务器就会返回304 not modified，如果修改了，就返回资源。</p>
</li>
<li><p>if-none-match:这个值的意义跟if-modified-since一样，也是一个条件请求，但这个值比上面的值有增强效果，因为文件即使修改时间变了，不一定说明资源变了。</p>
</li>
<li><p>Range：可以告诉服务器，只请求资源的一段，值可以是这样bytes=100-1000，通过这个，可以做到断点下载。</p>
</li>
<li><p>Authorization：当服务器资源需要权限才能访问时，客户端会带上这个请求头信息，将认证信息通过这个字段传递给服务器，通常这个值会采用base64编码，将username:password类型的值编码后通过网络传递给服务器，因为base64编码是可逆的，不够安全，所以现在的安全控制很少用这种方式，一般是用https。</p>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/16/apple/apple证书详解/">
                apple证书详解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-16
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/object-c/">object-c</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/16/apple/apple证书详解/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/16/apple/apple证书详解/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>刚接触iOS开发的人难免会对苹果的各种证书、配置文件等不甚了解，可能你按照网上的教程一步一步的成功申请了真机调试，但是还是对其中的缘由一知半解。这篇文章就对Certificate、Provisioning Profile等做个总结。</p>
<h1 id="概念介绍">概念介绍</h1><p>如果你拥有一个开发者账户的话，在iOS Dev Center打开Certificates, Indentifiers &amp; Profiles，你就可以看到如下的列表：</p>
<p><img src="/img/apple证书详解/1.png" alt="apple证书"></p>
<p>Profile Portal改版有一段时间了，改版之后的结构比以前更清晰明了，易于理解和管理。</p>
<p>上面的列表就包含了开发、调试和发布iOS应用程序所需的所有内容：Certificates、Identifiers、Devices、Provisioning Profiles。下面将一一解释这几个东东。</p>
<h2 id="Certificate">Certificate</h2><p>证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting的Code Signing Identity中，你可以设置用于为代码签名的证书。 </p>
<p>众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 </p>
<p><img src="/img/apple证书详解/2.png" alt="apple证书"></p>
<p>证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发应用程序（根据证书种类有不同作用），下面是证书的分类信息：（括号内为证书有效期）</p>
<blockquote>
<p>（注：不同类型的开发者账户所能创建的证书种类不同，关于开发者账户的对比和InHouse证书相关的内容，请见我的另一篇文章）</p>
</blockquote>
<ul>
<li>Development<ul>
<li>App Development (1年)：用来开发和真机调试应用程序。</li>
<li>Push Development (1年)：用来调试Apple Push Notification</li>
</ul>
</li>
<li>Production<ul>
<li>In-House and Ad Hoc (3年)：用来发布In-House和AdHoc的应用程序。</li>
<li>App Store ：用来发布提交App Store的应用程序。</li>
<li>MDM CSR</li>
<li>Push Production (1年)：用来在发布版本中使用Apple Push Notification。</li>
<li>Pass Type ID Certificate</li>
<li>Website Push ID Certificate</li>
</ul>
</li>
</ul>
<p>有一些类型的证书我没有使用过，所以也不了解具体的作用。</p>
<h3 id="App_ID">App ID</h3><p>App ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种： </p>
<ul>
<li>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。</li>
<li>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。</li>
</ul>
<p>每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。下面是目前所有可选的服务和相应的配置要求。</p>
<p><img src="/img/apple证书详解/3.png" alt="apple证书"></p>
<p>如果你的App使用上述的任何一种service，就要按照要求去配置。</p>
<h3 id="Device">Device</h3><p>Device最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。</p>
<p>每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。</p>
<p><strong>举例</strong></p>
<ol>
<li><p>假如第一年，你增加了70个设备，同时删除了10个设备，这个时候，虽然你的设备数是60，但是可用的增加测试机的名额却只有30个了。</p>
</li>
<li><p>到了第二年，你续费了开发者身份，在你第一次登陆进去后，你可以看到你的可用设备恢复成 100 – 60 = 40个了。这个时候，你可以选择删除一些设备，例如你又删除了20个设备，这样你的名额数变成60个。之后你增加了一个设备，因为你选择了增加新设备，苹果认为你已经放弃删除设备以恢复设备数的机会，这样，你的名额就固定成59个。以后删除设备都不会增加新名额了，直到你的下一个membership year开始时才又会有这样的机会来删除设备释放名额。</p>
</li>
</ol>
<p>那如果万一我的设备数达到上限，我又急需要增加新设备怎么办呢？</p>
<p>具体做法是访问：<a href="https://developer.apple.com/contact/" target="_blank" rel="external">https://developer.apple.com/contact/</a>，点击 Program Benefits， 然后在新出来的提交界面中将需求填上。之后苹果会发邮件过来告诉你处理结果，可能需要打电话过去和他们沟通一些细节。在沟通完成后，苹果就可以立即帮助你状态修改到“可删除设备来增加测试设备名额”。这样，你就可以选择性的删除一些不需要的设备来释放一些名额了。</p>
<h2 id="Provisioning_Profile">Provisioning Profile</h2><p>一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。</p>
<p>试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。</p>
<p>例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。</p>
<p><img src="/img/apple证书详解/4.png" alt="apple证书"></p>
<p>如上所述，在一台设备上运行应用程序的过程如下：</p>
<p><img src="/img/apple证书详解/5.png" alt="apple证书"></p>
<p>与证书一样，Provisioning Profile也分为Development和Distribution两种：</p>
<blockquote>
<p>（注：前面提到不同账户类型所能创建的证书种类不同，显然Profile文件的种类是和你所能创建的证书种类相关的）</p>
</blockquote>
<ul>
<li>Development (1年)</li>
<li>Distribution (1年)<ul>
<li>In House</li>
<li>Ad Hoc</li>
<li>App Store</li>
</ul>
</li>
</ul>
<p>In House 与Ad Hoc的不同之处在于：In House没有设备数量限制，而Ad Hoc是用来测试用的，Ad Hoc的包只能运行在该账户内已登记的可用设备上，显然是有最多100个设备的数量限制。所以这两种Provisioning Profile文件的区别就在于其中的设备限制不一样而已，而他们所使用的Certificate是相同的。    </p>
<h1 id="开发/发布流程">开发/发布流程</h1><p>了解了上面的概念，再来看开发及发布流程就非常简单了，而且相信你不用看教程也能一步步完成所有的操作了。</p>
<h2 id="开发/真机调试流程">开发/真机调试流程</h2><p>根据上面的介绍，可以知道进行Development主要有以下几个步骤：</p>
<ul>
<li>申请证书</li>
<li>加入设备</li>
<li>生成Provisioning Profile</li>
<li>设置Xcode Code Sign Identifer</li>
</ul>
<p>事实上第三步通常是不需要的，因为我们通常都是用Xcode生成和管理的iOS Team Provisioning Profile来进行开发，因为它非常方便，所以不需要自己手动生成Provisioning Profile。</p>
<p>iOS Team Provisioning Profile是第一次使用Xcode添加设备时，Xcode自动生成的，它包含了Xcode生成的一个Wildcard App ID（*，匹配所有应用程序），账户里面所有的Devices和所有Development Certificates，如下图所示。因此，team中的所有成员都可以使用这个iOS Team Provisioning Profile在team中的所有设备上调试所有的应用程序。并且当有新设备添加进来时，Xcode会更新这个文件。</p>
<p><img src="/img/apple证书详解/6.png" alt="apple证书"></p>
<h2 id="发布流程">发布流程</h2><p>网上有很多关于发布App Store的流程，我就不缀述了，不过根据上面的概念介绍，不管是App Store、In-House还是Ad-Hoc，打包流程都是差不多的，都包括了以下几个关键步骤：</p>
<ul>
<li>创建发布证书</li>
<li>创建App ID</li>
<li>创建对应的Provisioning Profile文件</li>
<li>设备Bundle ID和App ID一致</li>
<li>设置Xcode Code Sign Identifer，选择合适的Profile和证书进行签名，打包</li>
</ul>
<p>以上就是对证书、Provisioning Profile、App ID等的介绍。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/15/object-c/触摸事件/">
                触摸事件处理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-15
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/ios/">ios</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/15/object-c/触摸事件/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/15/object-c/触摸事件/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>iphone/ipad无键盘的设计是为屏幕争取更多的显示空间，大屏幕在观看图片、文字、视频等方面为用户带来了更好的用户体验。而触摸屏幕是iOS设备接受用户输入的主要方式，包括单击、双击、拨动以及多点触摸等，这些操作都会产生触摸事件。</p>
<p>在Cocoa中，代表触摸对象的类是<code>UITouch</code>。当用户触摸屏幕后，就会产生相应的事件，所有相关的UITouch对象都被包装在事件中，被程序交由特定的对象来处理。UITouch对象直接包括触摸的详细信息。</p>
<h2 id="UITouch类中包含5个属性：">UITouch类中包含5个属性：</h2><ol>
<li>window：触摸产生时所处的窗口。由于窗口可能发生变化，当前所在的窗口不一定是最开始的窗口。</li>
<li>view:触摸产生时所处的视图。由于视图可能发生变化，当前视图也不一定时最初的视图。</li>
<li>tapCount：轻击（Tap）操作和鼠标的单击操作类似，tapCount表示短时间内轻击屏幕的次数。因此可以根据tapCount判断单击、双击或更多的轻击。</li>
<li>timestamp：时间戳记录了触摸事件产生或变化时的时间。单位是秒。</li>
<li><p>phase：触摸事件在屏幕上有一个周期，即触摸开始、触摸点移动、触摸结束，还有中途取消。而通过phase可以查看当前触摸事件在一个周期中所处的状态。phase是<code>UITouchPhase</code>类型的，这是一个枚举配型，包含了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITouchPhaseBegan</span>（触摸开始）</span><br><span class="line"><span class="built_in">UITouchPhaseMoved</span>（接触点移动）</span><br><span class="line"><span class="built_in">UITouchPhaseStationary</span>（接触点无移动）</span><br><span class="line"><span class="built_in">UITouchPhaseEnded</span>（触摸结束）</span><br><span class="line"><span class="built_in">UITouchPhaseCancelled</span>（触摸取消）</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="UITouch类中包含如下成员函数：">UITouch类中包含如下成员函数：</h2><ul>
<li><p><code>- (CGPoint)locationInView:(UIView *)view</code>：函数返回一个CGPoint类型的值，表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置。</p>
</li>
<li><p><code>- (CGPoint)previousLocationInView:(UIView *)view</code>：该方法记录了前一个坐标值，函数返回也是一个CGPoint类型的值， 表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置。</p>
</li>
</ul>
<p>当手指接触到屏幕，不管是单点触摸还是多点触摸，事件都会开始，直到用户所有的手指都离开屏幕。期间所有的UITouch对象都被包含在UIEvent事件对象中，由程序分发给处理者。事件记录了这个周期中所有触摸对象状态的变化。</p>
<p>只要屏幕被触摸，系统就会报若干个触摸的信息封装到UIEvent对象中发送给程序，由管理程序UIApplication对象将事件分发。一般来说，事件将被发给主窗口，然后传给第一响应者对象(<code>FirstResponder</code>)处理。</p>
<p>关于响应者的概念，通过以下几点说明：</p>
<ul>
<li><p>响应者对象（Response object）</p>
<p>响应者对象就是可以响应事件并对事件作出处理。在iOS中，存在UIResponder类，它定义了响应者对象的所有方法。UIApplication、UIView等类都继承了UIResponder类，UIWindow和UIKit中的控件因为继承了UIView，所以也间接继承了UIResponder类，这些类的实例都可以当作响应者。</p>
</li>
<li><p>第一响应者（First responder）</p>
<p>当前接受触摸的响应者对象被称为第一响应者，即表示当前该对象正在与用户交互，它是响应者链的开端。</p>
</li>
<li><p>响应者链（Responder chain）</p>
<p>响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者（next responder）。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow对象）再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>
</li>
<li><p>管理事件分发</p>
<p>视图对触摸事件是否需要作处回应可以通过设置视图的<code>userInteractionEnabled</code>属性。默认状态为<code>YES</code>，如果设置为<code>NO</code>，可以阻止视图接收和分发触摸事件。除此之外，当视图被隐藏（<code>setHidden：YES</code>）或者透明（<code>alpha</code>值为0）也不会收事件。不过这个属性只对视图有效，如果想要整个程序都步响应事件，可以调用<code>UIApplication</code>的<code>beginIngnoringInteractionEvents</code>方法来完全停止事件接收和分发。通过<code>endIngnoringInteractionEvents</code>方法来恢复让程序接收和分发事件。</p>
</li>
</ul>
<p>如果要让视图接收多点触摸，需要设置它的<code>multipleTouchEnabled</code>属性为<code>YES</code>，默认状态下这个属性值为<code>NO</code>，即视图默认不接收多点触摸。</p>
<h2 id="如何处理用户的触摸事件">如何处理用户的触摸事件</h2><p>*首先触摸的对象是视图，而视图的类UIView继承了UIRespnder类，但是要对事件作出处理，还需要重写UIResponder类中定义的事件处理函数。根据不通的触摸状态，程序会调用相应的处理函数，这些函数包括以下几个：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当手指接触屏幕时，就会调用touchesBegan:withEvent方法；</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesBegan:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指在屏幕上移时，动就会调用touchesMoved:withEvent方法；</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesMoved:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指离开屏幕时，就会调用touchesEnded:withEvent方法；</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesEnded:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当触摸被取消（比如触摸过程中被来电打断），就会调用touchesCancelled:withEvent方法。</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesCancelled:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<p>而这几个方法被调用时，正好对应了<code>UITouch</code>类中<code>phase</code>属性的4个枚举值。</p>
<p>上面的四个事件方法，在开发过程中并不要求全部实现，可以根据需要重写特定的方法。对于这4个方法，都有两个相同的参数：<code>NSSet</code>类型的<code>touches</code>和<code>UIEvent</code>类型的<code>event</code>。其中touches表示触摸产生的所有<code>UITouch</code>对象，而event表示特定的事件。因为<code>UIEvent</code>包含了整个触摸过程中所有的触摸对象，因此可以调用<code>allTouches</code>方法获取该事件内所有的触摸对象，也可以调用<code>touchesForVIew</code>：或者<code>touchesForWindows</code>：取出特定视图或者窗口上的触摸对象。在这几个事件中，都可以拿到触摸对象，然后根据其位置，状态，时间属性做逻辑处理。</p>
<p>例如:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch =  [touches anyObject];</span><br><span class="line">    <span class="keyword">if</span>(touch<span class="variable">.tapCount</span> == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子说明在触摸手指离开后，根据tapCount点击的次数来设置当前视图的背景色。不管时一个手指还是多个手指，轻击操作都会使每个触摸对象的tapCount加1，由于上面的例子不需要知道具体触摸对象的位置或时间等，因此可以直接调用touches的anyObject方法来获取任意一个触摸对象然后判断其tapCount的值即可。</p>
<p>检测tapCount可以放在touchesBegan也可以touchesEnded，不过一般后者跟准确，因为touchesEnded可以保证所有的手指都已经离开屏幕，这样就不会把轻击动作和按下拖动等动作混淆。</p>
<p>轻击操作很容易引起歧义，比如当用户点了一次之后，并不知道用户是想单击还是只是双击的一部分，或者点了两次之后并不知道用户是想双击还是继续点击。为了解决这个问题，一般可以使用“<strong>延迟调用</strong>”函数。</p>
<p>例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch =  [touches anyObject];</span><br><span class="line">    <span class="keyword">if</span>(touch<span class="variable">.tapCount</span> == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(setBackground:) withObject:[<span class="built_in">UIColor</span> blueColor] afterDelay:<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示在第一次轻击之后，没有直接更改视图的背景属性，而是通过<code>performSelector：withObject：afterDelay</code>：方法设置2秒中后更改。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch =  [touches anyObject];</span><br><span class="line">    <span class="keyword">if</span>(touch<span class="variable">.tapCount</span> == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(setBackground:) object:[<span class="built_in">UIColor</span> redColor]];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双击就是两次单击的组合，因此在第一次点击的时候，设置背景色的方法已经启动，在检测到双击的时候先要把先前对应的方法取消掉，可以通过调用NSObject类的<code>cancelPreviousPerformRequestWithTarget:selector:object</code>方法取消指定对象的方法调用，然后调用双击对应的方法设置背景色为红色。</p>
<p>下面举个例子创建可以拖动的视图，这个主要通过触摸对象的位置坐标来实现。因此调用触摸对象的locationInView：方法即可。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGPoint</span> originalLocation;</span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    originalLocation = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> currentLocation = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.x</span> += currentLocation<span class="variable">.x</span>-originalLocation<span class="variable">.x</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.y</span> += currentLocation<span class="variable">.y</span>-originalLocation<span class="variable">.y</span>;   </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先在<code>touchesBegan</code>中通过<code>[touch locationInView:self.view]</code>获取手指触摸在当前视图上的位置，用<code>CGPoint</code>变量记录，然后在手指移动事件touchesMoved方法中获取触摸对象当前位置，并通过于与原始位置的差值计算出移动偏移量，再设置当前视图的位置。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/10/cpp/stl_map与boost_unordered_map/">
                STL map与Boost unordered_map
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/10/cpp/stl_map与boost_unordered_map/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/10/cpp/stl_map与boost_unordered_map/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="STL_map与Boost_unordered_map">STL map与Boost unordered_map</h1><p>今天看到 boost::unordered_map， 它与 stl::map的区别就是，stl::map是按照operator&lt;比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator&lt; 定义的大小排序。</p>
<p>而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对unordered_map进行遍历，结果是无序的。</p>
<p>用法的区别就是，stl::map 的key需要定义operator&lt; 。 而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator&lt; 或者hash_value()了。 </p>
<p>最后，说，当不需要结果排好序时，最好用unordered_map。</p>
<p>其实，stl::map对于与java中的TreeMap，而boost::unordered_map对应于java中的HashMap。 </p>
<h2 id="stl::map">stl::map</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	int age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">person</span>(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;name =  name;</span><br><span class="line">		this-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const <span class="keyword">person</span>&amp; p) const</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;age &lt; p.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">person</span>,int&gt; m;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">person</span> p1(<span class="string">"Tom1"</span>,20);</span><br><span class="line">	<span class="keyword">person</span> p2(<span class="string">"Tom2"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p3(<span class="string">"Tom3"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p4(<span class="string">"Tom4"</span>,23);</span><br><span class="line">	<span class="keyword">person</span> p5(<span class="string">"Tom5"</span>,24);</span><br><span class="line">	m.insert(make_pair(p3, 100));</span><br><span class="line">	m.insert(make_pair(p4, 100));</span><br><span class="line">	m.insert(make_pair(p5, 100));</span><br><span class="line">	m.insert(make_pair(p1, 100));</span><br><span class="line">	m.insert(make_pair(p2, 100));</span><br><span class="line">	</span><br><span class="line">	for(map&lt;<span class="keyword">person</span>, int&gt;::iterator iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;iter-&gt;first.name&lt;&lt;<span class="string">"\t"</span>&lt;&lt;iter-&gt;first.age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Tom1    20</span><br><span class="line">Tom3    22</span><br><span class="line">Tom4    23</span><br><span class="line">Tom5    24</span><br></pre></td></tr></table></figure>
<blockquote>
<p>operator&lt;的重载一定要定义成const。因为map内部实现时调用operator&lt;的函数好像是const。</p>
<p>由于operator&lt;比较的只是age,所以因为Tom2和Tom3的age相同，所以最终结果里面只有Tom3，没有Tom2</p>
</blockquote>
<h2 id="boost::unordered_map">boost::unordered_map</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;boost/unordered_map.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	int age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">person</span>(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;name =  name;</span><br><span class="line">		this-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator== (const <span class="keyword">person</span>&amp; p) const</span><br><span class="line">	&#123;</span><br><span class="line">		return name==p.name &amp;&amp; age==p.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">size_t hash_value(const <span class="keyword">person</span>&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	size_t seed = 0;</span><br><span class="line">	boost::hash_combine(seed, boost::hash_value(p.name));</span><br><span class="line">	boost::hash_combine(seed, boost::hash_value(p.age));</span><br><span class="line">	return seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	typedef boost::unordered_map&lt;<span class="keyword">person</span>,int&gt; umap;</span><br><span class="line">	umap m;</span><br><span class="line">	<span class="keyword">person</span> p1(<span class="string">"Tom1"</span>,20);</span><br><span class="line">	<span class="keyword">person</span> p2(<span class="string">"Tom2"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p3(<span class="string">"Tom3"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p4(<span class="string">"Tom4"</span>,23);</span><br><span class="line">	<span class="keyword">person</span> p5(<span class="string">"Tom5"</span>,24);</span><br><span class="line">	m.insert(umap::value_type(p3, 100));</span><br><span class="line">	m.insert(umap::value_type(p4, 100));</span><br><span class="line">	m.insert(umap::value_type(p5, 100));</span><br><span class="line">	m.insert(umap::value_type(p1, 100));</span><br><span class="line">	m.insert(umap::value_type(p2, 100));</span><br><span class="line">	</span><br><span class="line">	for(umap::iterator iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;iter-&gt;first.name&lt;&lt;<span class="string">"\t"</span>&lt;&lt;iter-&gt;first.age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Tom1    20</span><br><span class="line">Tom5    24</span><br><span class="line">Tom4    23</span><br><span class="line">Tom2    22</span><br><span class="line">Tom3    22</span><br></pre></td></tr></table></figure>
<blockquote>
<p>必须要自定义operator==和hash_value。 重载operator==是因为，如果两个元素的hash_value的值相同，并不能断定这两个元素就相同，必须再调用operator==。 当然，如果hash_value的值不同，就不需要调用operator==了。</p>
</blockquote>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/08/cpp/std_function和std_bind/">
                c++11中的bind和function
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-08
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/08/cpp/std_function和std_bind/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/08/cpp/std_function和std_bind/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="c++11中的bind和function">c++11中的bind和function</h1><h2 id="std::function">std::function</h2><p>它是函数、函数对象、函数指针、和成员函数的包装器，可以容纳任何类型的函数对象，函数指针，引用函数，成员函数的指针。<br>以统一的方式处理函数、函数对象、函数指针、和成员函数。</p>
<p>允许保存和延迟执行函数。</p>
<ul>
<li>函数和成员函数作为function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">G</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">H</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f = G; <span class="comment">//全局函数</span></span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f <span class="number">1</span>= <span class="built_in">std</span>::bind(&amp;A::H, a); <span class="comment">//成员函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以用function取代函数指针。因为它可以保存函数延迟执行，所以比较适合作为回调函数，也可以把它看做类似于c#中特殊的委托，只有一个成员的委托。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">A(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&amp; f):m_callback(f)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">m_callback();<span class="comment">//回调到上层</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; m_callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>function还可以作为函数入参，这样可以在函数外部控制函数的内部行为了，让我们的函数变得更加灵活。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)</span>&gt;&amp; f)</span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">f(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x+<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFoo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(G, <span class="built_in">std</span>::placeholders::_1); </span><br><span class="line">Foo(<span class="number">4</span>, f);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Foo函数外面更改f的行为</span></span><br><span class="line">f = <span class="built_in">std</span>::bind(H, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">Foo(<span class="number">4</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std::bind绑定器">std::bind绑定器</h2><ul>
<li>将函数、成员函数和闭包转成function函数对象</li>
<li>将多元(n&gt;1)函数转成一元函数或者(n-1)元函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="comment">//绑定全局函数</span></span><br><span class="line"><span class="keyword">auto</span> f11 = <span class="built_in">std</span>::bind(H, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"><span class="keyword">auto</span>的类型实际上是<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定带参数的成员函数</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">char</span>*, <span class="keyword">int</span>)&gt; f = <span class="built_in">std</span>::bind(&amp;ReadHandler::ConnectPreProcess, <span class="keyword">this</span>, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三元函数转换成一元函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="comment">// 绑定f()函数调用的第二个和第三个参数，</span></span><br><span class="line"><span class="comment">// 返回一个新的函数对象为ff，它只带有一个int类型的参数</span></span><br><span class="line"><span class="keyword">auto</span> ff = bind(f, _1, ‘c’, <span class="number">1.2</span>);    </span><br><span class="line"><span class="keyword">int</span> x = ff(<span class="number">7</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>bind简化和增强bind1st和bind2nd</li>
</ul>
<p>其实bind简化和增强了之前标准库中bind1st和bind2nd，它完全可以替代bind1s和bind2st，并且能组合函数。我们知道bind1st和bind2nd将一个二元算子转换成一个一元算子。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素值大于10的元素的个数</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, std::bind1st<span class="params">(less&lt;int&gt;<span class="params">()</span>, <span class="number">10</span>)</span>)</span>;</span><br><span class="line"><span class="comment">//查找元素之小于10的元素</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, std::bind2nd<span class="params">(less&lt;int&gt;<span class="params">()</span>, <span class="number">10</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>本质上是对一个二元函数less<int>的调用，但是它却要分别用bind1st和bind2nd，而且还要想想到底是用bind1st还是bind2nd，用起来感觉不方便。现在用bind，就可以以统一的方式去实现了。</int></p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素值大于10的元素的个数</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, bind<span class="params">(less&lt;int&gt;<span class="params">()</span>, <span class="number">10</span>, _1)</span>)</span>;</span><br><span class="line"><span class="comment">//查找元素之小于10的元素</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, bind<span class="params">(less&lt;int&gt;<span class="params">()</span>, _1, <span class="number">10</span>)</span>)</span>;</span><br><span class="line">这样我就不用关心到底是用bind1st还是bind2nd了，只要用bind就都搞定了。</span><br></pre></td></tr></table></figure>
<ul>
<li>bind函数组合</li>
</ul>
<p>bind的还有一个强大之处就是函数组合。假设我们要找出集合中大于5小于10的元素个数怎么做呢？我们需要一个逻辑与才能做到类似于： </p>
<p><code>std::bind(std::logical_and&lt;bool&gt;(),_1,_2);</code></p>
<p>然后，我们需要另一个谓词来回答 _1 是否大于5。</p>
<p><code>std::bind(std::greater&lt;int&gt;(),_1,5);</code></p>
<p>然后，我们还需要另一个谓词来回答 _1 是否小于等于10。</p>
<p><code>std::bind(std::less_equal&lt;int&gt;(),_1,10);</code></p>
<p>最后，我们需要把它们两个用逻辑与合起来，就象这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找集合中大于5小于10的元素个数</span></span><br><span class="line"><span class="keyword">auto</span> f = bind(<span class="built_in">std</span>::logical_and&lt;<span class="keyword">bool</span>&gt;(), bind(<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">5</span>), bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">int</span> count = count_if(coll.begin(), coll.end(), f);</span><br></pre></td></tr></table></figure>
<p>c++11中推出function是为了泛化函数对象，函数指针，引用函数，成员函数的指针，让我们可以按更统一的方式写出更加泛化的代码；推出bind是为了替换和增强之前标准库的bind1st和bind2st，让我们的用起来更方便！</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/07/cpp/std_find,std_find_if/">
                std::find,std::find_if
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/07/cpp/std_find,std_find_if/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/07/cpp/std_find,std_find_if/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="std::find,std::find_if">std::find,std::find_if</h1><ul>
<li>STL的find，find_if函数提供了一种对数组、STL容器进行查找的方法。使用该函数，需 #include <algorithm>,我们查找一个list中的数据，通常用find()，例如：</algorithm></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line">	lst.push_back(<span class="number">10</span>);</span><br><span class="line">	lst.push_back(<span class="number">20</span>);</span><br><span class="line">	lst.push_back(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(lst.begin(), lst.end(), <span class="number">10</span>); <span class="comment">// 查找list中是否有元素“10”</span></span><br><span class="line">	<span class="keyword">if</span> (it != lst.end()) <span class="comment">// 找到了</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// do something </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">// 没找到</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>那么，如果容器里的元素是一个类呢？例如，有list<cperson> ，其中CPerson类定义如下：</cperson></li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CPerson(<span class="keyword">void</span>); ~CPerson(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么如何用find()函数进行查找呢？这时，我们需要提供一个判断两个CPerson对象“相等”的定义，find()函数才能从一个list中找到与指定的CPerson“相等”的元素。</p>
<p>这个“相等”的定义，是通过重载“==”操作符实现的，我们在CPerson类中添加一个方法，定义为：</p>
<p><code>bool operator==(const CPerson &amp;rhs) const;</code></p>
<p>实现为：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="attribute">CPerson</span>::operator==(<span class="keyword">const</span> CPerson &amp;rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (id == rhs.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="pi">//然后我们就可以这样查找（假设list中已经有了若干CPerson对象）了：</span><br><span class="line">list&lt;CPerson&gt; lst;</span><br><span class="line">//</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span></span><br><span class="line"><span class="pi">// 向lst中添加元素，此处省略</span><br><span class="line">//</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span></span><br><span class="line">CPerson cp_to_find; <span class="pi">// 要查找的对象</span><br><span class="line">cp_to_find.age = 50;</span><br><span class="line">list&lt;CPerson&gt;::iterator it = find(list.begin(), list.end(), cp_to_find); //</span> 查找</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">it</span> != lst.end()) <span class="pi">// 找到了</span><br><span class="line">&#123;</span><br><span class="line">	//</span> <span class="keyword">do</span> something </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="pi">// 没找到</span><br><span class="line">&#123;</span><br><span class="line">	//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有人说，如果我有自己定义的“相等”呢？例如，有一个list<cperson*>，这个list中的每一个元素都是一个对象的指针，我们要在这个list中查找具有指定age的元素，找到的话就得到对象的指针。</cperson*></li>
</ul>
<p>这时候，你不再能像上面的例子那样做，我们需要用到find_if函数，并自己指定predicate function（即find_if函数的第三个参数，请查阅STL手册）。先看看find_if函数的定义：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">InputIterator</span>, class <span class="type">Predicate</span>&gt;</span><br><span class="line">   <span class="type">InputIterator</span> find_if(<span class="type">InputIterator</span> _First, <span class="type">InputIterator</span> _Last, <span class="type">Predicate</span> _Pred);</span><br><span class="line"><span class="type">Parameters</span></span><br><span class="line">_First</span><br><span class="line"><span class="type">An</span> input <span class="keyword">iterator</span> addressing the position <span class="keyword">of</span> the first element <span class="keyword">in</span> the <span class="type">range</span> </span><br><span class="line">to be searched.</span><br><span class="line"></span><br><span class="line">_Last</span><br><span class="line"><span class="type">An</span> input <span class="keyword">iterator</span> addressing the position one past the final element <span class="keyword">in</span> the </span><br><span class="line"><span class="type">range</span> to be searched.</span><br><span class="line"></span><br><span class="line">_Pred</span><br><span class="line"><span class="type">User</span>-defined predicate function <span class="keyword">object</span> that defines the condition to be </span><br><span class="line">satisfied by the element being searched <span class="keyword">for</span>. A predicate takes single argument </span><br><span class="line"><span class="keyword">and</span> returns <span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>.</span><br></pre></td></tr></table></figure>
<p>我们在CPerson类外部定义这样一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">finder_t</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">finder_t</span>(<span class="keyword">int</span> n): age(n)	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(CPerson *p)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (age == p-&gt;age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>	age;</span><br><span class="line">&#125;<span class="keyword">finder_t</span>;</span><br></pre></td></tr></table></figure>
<p>然后就可以利用find_if函数来查找了：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list&lt;CPerson*&gt; lst;</span><br><span class="line"><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">//</span><br><span class="line">//</span> 向lst中添加元素，此处省略</span><br><span class="line"><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">//</span><br><span class="line">list&lt;CPerson*&gt;::iterator it = find_if(lst.begin(), lst.end(), finder_t(50));	//</span> 查找年龄为<span class="number">50</span>的人</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">it</span> != lst.end())	<span class="pi">// 找到了</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; "Found person with age : " &lt;&lt; (*it)-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line">else	//</span> 没找到</span><br><span class="line">&#123;</span><br><span class="line">	<span class="pi">// do something</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="zhulei" />
          <p class="site-author-name">zhulei</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">69</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">49</span>
              <span class="site-state-item-name">標籤</span>
              
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/zl8522115" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://twitter.com/zl8522115" target="_blank">Twitter</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/zlsky" target="_blank">Weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/zhu-lei-46-87" target="_blank">ZhiHu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2012 - 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">zhulei</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"threestone"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

</body>
</html>
