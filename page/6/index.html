<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>




  <meta name="keywords" content="zhulei,golang,js,php,opengl" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> Three Stone </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Three Stone</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首頁
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          關於
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          歸檔
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/10/13/php/设计模式/">
                设计模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-10-13
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/php/">php</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/10/13/php/设计模式/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/13/php/设计模式/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="单例模式">单例模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>
<span class="comment">/**
 * 单例模式
 *
 */</span>
<span class="class"><span class="keyword">class</span> <span class="title">DbConn</span>
</span>{
       <span class="keyword">private</span> <span class="keyword">static</span> <span class="variable">$_instance</span> = <span class="keyword">null</span>;
       <span class="keyword">protected</span> <span class="keyword">static</span> <span class="variable">$_counter</span> = <span class="number">0</span>;
       <span class="keyword">protected</span> <span class="variable">$_db</span>;
       <span class="comment">//私有化构造函数，不允许外部创建实例</span>
       <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span>
       </span>{
              <span class="keyword">self</span>::<span class="variable">$_counter</span> += <span class="number">1</span>;
       }

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span>
       </span>{
              <span class="keyword">if</span> (<span class="keyword">self</span>::<span class="variable">$_instance</span> == <span class="keyword">null</span>)
              {
                     <span class="keyword">self</span>::<span class="variable">$_instance</span> = <span class="keyword">new</span> DbConn();
              }
              <span class="keyword">return</span> <span class="keyword">self</span>::<span class="variable">$_instance</span>;
       }

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span>
       </span>{
              <span class="keyword">echo</span> <span class="string">"connected: "</span>.(<span class="keyword">self</span>::<span class="variable">$_counter</span>).<span class="string">"n"</span>;
              <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_db;
       }
}
<span class="comment">/*
 * 不使用单例模式时，删除构造函数的private后再测试，第二次调用构造函数后，_counter变成2
*/</span>
<span class="comment">// $conn = new DbConn();</span>
<span class="comment">// $conn-&gt;connect();</span>
<span class="comment">// $conn = new DbConn();</span>
<span class="comment">// $conn-&gt;connect();</span>
<span class="comment">//使用单例模式后不能直接new对象，必须调用getInstance获取</span>
<span class="variable">$conn</span> = DbConn::getInstance();
<span class="variable">$db</span> = <span class="variable">$conn</span>-&gt;connect();
<span class="comment">//第二次调用是同一个实例，_counter还是1</span>
<span class="variable">$conn</span> = DbConn::getInstance();
<span class="variable">$db</span> = <span class="variable">$conn</span>-&gt;connect();
<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>特别说明：这里getInstance里有if判断然后再生成对象，在多线程语言里是会有并发问题的。例如java的解决方案有二个，给方法加上synchronized关键词变成同步，或者把_instanc的初始化提前放到类成员变量定义时，但是这2种方式php都不支持。不过因为php不支持多线程所以不需要考虑这个问题了。</li>
</ul>
<h2 id="工厂模式">工厂模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>
<span class="comment">/**
 *
 * 工厂模式
 *
 */</span>

<span class="comment">//抽象产品</span>
<span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>{
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span>; 
}
<span class="comment">//具体产品实现</span>
<span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"老师n"</span>;
    }
}
<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"学生n"</span>;
    }
}

<span class="comment">//简单工厂</span>
<span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>{
       <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">(<span class="variable">$type</span>)</span> </span>{
              <span class="variable">$person</span> = <span class="keyword">null</span>;
              <span class="keyword">if</span> (<span class="variable">$type</span> == <span class="string">'teacher'</span>) {
                     <span class="variable">$person</span> = <span class="keyword">new</span> Teacher();
              } <span class="keyword">elseif</span> (<span class="variable">$type</span> == <span class="string">'student'</span>) {
                     <span class="variable">$person</span> = <span class="keyword">new</span> Student();
              }
              <span class="keyword">return</span> <span class="variable">$person</span>;
       }
}

<span class="comment">//简单工厂调用</span>
<span class="class"><span class="keyword">class</span> <span class="title">SimpleClient</span> </span>{
       <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>{
              <span class="comment">// 如果不用工厂模式，则需要提前指定具体类</span>
              <span class="comment">// $person = new Teacher();</span>
              <span class="comment">// echo $person-&gt;getName();</span>
              <span class="comment">// $person = new Student();</span>
              <span class="comment">// echo $person-&gt;getName();</span>

              <span class="comment">// 用工厂模式，则不需要知道对象由什么类产生，交给工厂去决定</span>
              <span class="variable">$person</span> = SimpleFactory::getPerson(<span class="string">'teacher'</span>);
              <span class="keyword">echo</span> <span class="variable">$person</span>-&gt;getName();
              <span class="variable">$person</span> = SimpleFactory::getPerson(<span class="string">'student'</span>);
              <span class="keyword">echo</span> <span class="variable">$person</span>-&gt;getName();
       }
}


<span class="comment">//工厂方法</span>
<span class="class"><span class="keyword">interface</span> <span class="title">CommFactory</span> </span>{
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span></span>;
}
<span class="comment">//具体工厂实现</span>
<span class="class"><span class="keyword">class</span> <span class="title">StudentFactory</span> <span class="keyword">implements</span> <span class="title">CommFactory</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Student();
    }
}
<span class="class"><span class="keyword">class</span> <span class="title">TeacherFactory</span> <span class="keyword">implements</span> <span class="title">CommFactory</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Teacher();
    }
}

<span class="comment">//工厂方法调用</span>
<span class="class"><span class="keyword">class</span> <span class="title">CommClient</span> </span>{
    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>{
           <span class="variable">$factory</span> = <span class="keyword">new</span> TeacherFactory();
           <span class="keyword">echo</span> <span class="variable">$factory</span>-&gt;getPerson()-&gt;getName();
           <span class="variable">$factory</span> = <span class="keyword">new</span> StudentFactory();
           <span class="keyword">echo</span> <span class="variable">$factory</span>-&gt;getPerson()-&gt;getName();
    }
}



<span class="comment">//抽象工厂模式另一条产品线</span>
<span class="class"><span class="keyword">interface</span> <span class="title">Grade</span> </span>{
       <span class="function"><span class="keyword">function</span> <span class="title">getYear</span><span class="params">()</span></span>;
}
<span class="comment">//另一条产品线的具体产品</span>
<span class="class"><span class="keyword">class</span> <span class="title">Grade1</span> <span class="keyword">implements</span> <span class="title">Grade</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getYear</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="string">'2003级'</span>;
       }
}
<span class="class"><span class="keyword">class</span> <span class="title">Grade2</span> <span class="keyword">implements</span> <span class="title">Grade</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getYear</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="string">'2004级'</span>;
       }
}
<span class="comment">//抽象工厂</span>
<span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>{
       <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span></span>;
       <span class="function"><span class="keyword">function</span> <span class="title">getGrade</span><span class="params">()</span></span>;
}
<span class="comment">//具体工厂可以产生每个产品线的产品</span>
<span class="class"><span class="keyword">class</span> <span class="title">Grade1TeacherFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Teacher();
       }
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getGrade</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Grade1();
       }
}
<span class="class"><span class="keyword">class</span> <span class="title">Grade1StudentFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Student();
       }
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getGrade</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Grade1();
       }
}
<span class="class"><span class="keyword">class</span> <span class="title">Grade2TeacherFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>{
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPerson</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Teacher();
       }
       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getGrade</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="keyword">new</span> Grade2();
       }
}
<span class="comment">//抽象工厂调用</span>
<span class="class"><span class="keyword">class</span> <span class="title">FactoryClient</span> </span>{
       <span class="function"><span class="keyword">function</span> <span class="title">printInfo</span><span class="params">(<span class="variable">$factory</span>)</span> </span>{
              <span class="keyword">echo</span> <span class="variable">$factory</span>-&gt;getGrade()-&gt;getYear().<span class="variable">$factory</span>-&gt;getPerson()-&gt;getName();
       }
       <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>{
              <span class="variable">$client</span> = <span class="keyword">new</span> FactoryClient();
              <span class="variable">$factory</span> = <span class="keyword">new</span> Grade1TeacherFactory();
              <span class="variable">$client</span>-&gt;printInfo(<span class="variable">$factory</span>);
              <span class="variable">$factory</span> = <span class="keyword">new</span> Grade1StudentFactory();
              <span class="variable">$client</span>-&gt;printInfo(<span class="variable">$factory</span>);
              <span class="variable">$factory</span> = <span class="keyword">new</span> Grade2TeacherFactory();
              <span class="variable">$client</span>-&gt;printInfo(<span class="variable">$factory</span>);
       }
}


<span class="comment">//简单工厂</span>
<span class="comment">//SimpleClient::main();</span>
<span class="comment">//工厂方法</span>
<span class="comment">//CommClient::main();</span>
<span class="comment">//抽象工厂</span>
FactoryClient::main();

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>三种工厂的区别是，抽象工厂由多条产品线，而工厂方法只有一条产品线，是抽象工厂的简化。而工厂方法和简单工厂相对，大家初看起来好像工厂方法增加了许多代码但是实现的功能和简单工厂一样。但本质是，简单工厂并未严格遵循设计模式的开闭原则，当需要增加新产品时也需要修改工厂代码。但是工厂方法则严格遵守开闭原则，模式只负责抽象工厂接口，具体工厂交给客户去扩展。在分工时，核心工程师负责抽象工厂和抽象产品的定义，业务工程师负责具体工厂和具体产品的实现。只要抽象层设计的好，框架就是非常稳定的。</li>
</ul>
<h2 id="创建者模式">创建者模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>
<span class="comment">/**
 *
 * 创建者模式
 *
 */</span>

<span class="comment">//购物车</span>
<span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>{
       <span class="comment">//选中的商品</span>
    <span class="keyword">private</span> <span class="variable">$_goods</span> = <span class="keyword">array</span>();
    <span class="comment">//使用的优惠券</span>
    <span class="keyword">private</span> <span class="variable">$_tickets</span> = <span class="keyword">array</span>();

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addGoods</span><span class="params">(<span class="variable">$goods</span>)</span> </span>{
              <span class="variable">$this</span>-&gt;_goods[] = <span class="variable">$goods</span>;
       }

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addTicket</span><span class="params">(<span class="variable">$ticket</span>)</span> </span>{
           <span class="variable">$this</span>-&gt;_tickets[] = <span class="variable">$ticket</span>;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">printInfo</span><span class="params">()</span> </span>{
           printf(<span class="string">"goods:%s, tickets:%sn"</span>, implode(<span class="string">','</span>, <span class="variable">$this</span>-&gt;_goods), implode(<span class="string">','</span>, <span class="variable">$this</span>-&gt;_tickets));
    }
}

<span class="comment">//假如我们要还原购物车的东西，比如用户关闭浏览器后再打开时会根据cookie还原</span>
<span class="variable">$data</span> = <span class="keyword">array</span>(
       <span class="string">'goods'</span> =&gt; <span class="keyword">array</span>(<span class="string">'衣服'</span>, <span class="string">'鞋子'</span>),
       <span class="string">'tickets'</span> =&gt; <span class="keyword">array</span>(<span class="string">'减10'</span>),
);

<span class="comment">//如果不使用创建者模式，则需要业务类里一步步还原购物车</span>
<span class="comment">// $cart = new ShoppingCart();</span>
<span class="comment">// foreach ($data['goods'] as $goods) {</span>
<span class="comment">//   $cart-&gt;addGoods($goods);</span>
<span class="comment">// }</span>
<span class="comment">// foreach ($data['tickets'] as $ticket) {</span>
<span class="comment">//   $cart-&gt;addTicket($ticket);</span>
<span class="comment">// }</span>
<span class="comment">// $cart-&gt;printInfo();</span>
<span class="comment">// exit;</span>


<span class="comment">//我们提供创建者类来封装购物车的数据组装</span>
<span class="class"><span class="keyword">class</span> <span class="title">CardBuilder</span> </span>{
       <span class="keyword">private</span> <span class="variable">$_card</span>;
       <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$card</span>)</span> </span>{
              <span class="variable">$this</span>-&gt;_card = <span class="variable">$card</span>;
       }
       <span class="function"><span class="keyword">function</span> <span class="title">build</span><span class="params">(<span class="variable">$data</span>)</span> </span>{
              <span class="keyword">foreach</span> (<span class="variable">$data</span>[<span class="string">'goods'</span>] <span class="keyword">as</span> <span class="variable">$goods</span>) {
                     <span class="variable">$this</span>-&gt;_card-&gt;addGoods(<span class="variable">$goods</span>);
              }
              <span class="keyword">foreach</span> (<span class="variable">$data</span>[<span class="string">'tickets'</span>] <span class="keyword">as</span> <span class="variable">$ticket</span>) {
                     <span class="variable">$this</span>-&gt;_card-&gt;addTicket(<span class="variable">$ticket</span>);
              }
       }
       <span class="function"><span class="keyword">function</span> <span class="title">getCrad</span><span class="params">()</span> </span>{
              <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_card;
       }
}

<span class="variable">$cart</span> = <span class="keyword">new</span> ShoppingCart();
<span class="variable">$builder</span> = <span class="keyword">new</span> CardBuilder(<span class="variable">$cart</span>);
<span class="variable">$builder</span>-&gt;build(<span class="variable">$data</span>);
<span class="keyword">echo</span> <span class="string">"after builder:n"</span>;
<span class="variable">$cart</span>-&gt;printInfo();

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>可以看出，使用创建者模式对内部数据复杂的对象封装数据组装过程后，对外接口就会非常简单和规范，增加修改新数据项也不会对外部造成任何影响。</li>
</ul>
<h2 id="原型模式">原型模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>
<span class="comment">/**
 *
 * 原型模式
 */</span>

<span class="comment">//声明一个克隆自身的接口</span>
<span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">()</span></span>; 
}   

<span class="comment">//产品要实现克隆自身的操作</span>
<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>{
       <span class="comment">//简单起见，这里没有使用get set</span>
    <span class="keyword">public</span> <span class="variable">$school</span>;
    <span class="keyword">public</span> <span class="variable">$major</span>;
       <span class="keyword">public</span> <span class="variable">$name</span>;

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$school</span>, <span class="variable">$major</span>, <span class="variable">$name</span>)</span> </span>{
              <span class="variable">$this</span>-&gt;school = <span class="variable">$school</span>;
              <span class="variable">$this</span>-&gt;major = <span class="variable">$major</span>;
              <span class="variable">$this</span>-&gt;name = <span class="variable">$name</span>;
       }

       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">printInfo</span><span class="params">()</span> </span>{
              printf(<span class="string">"%s,%s,%sn"</span>, <span class="variable">$this</span>-&gt;school, <span class="variable">$this</span>-&gt;major, <span class="variable">$this</span>-&gt;name);
       }

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">()</span> </span>{
           <span class="keyword">return</span> <span class="keyword">clone</span> <span class="variable">$this</span>;
    }
}

<span class="variable">$stu1</span> = <span class="keyword">new</span> Student(<span class="string">'清华大学'</span>, <span class="string">'计算机'</span>, <span class="string">'张三'</span>);
<span class="variable">$stu1</span>-&gt;printInfo();

<span class="variable">$stu2</span> = <span class="variable">$stu1</span>-&gt;copy();
<span class="variable">$stu2</span>-&gt;name = <span class="string">'李四'</span>;
<span class="variable">$stu2</span>-&gt;printInfo();

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>这里可以看到，如果类的成员变量非常多，如果由外部创建多个新对象再一个个赋值，则效率不高代码冗余也容易出错，通过原型拷贝复制自身再进行微小修改就是另一个新对象了。</li>
</ul>
<h2 id="适配器模式">适配器模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>  
<span class="comment">/**  
 *  
 * 适配器模式  
 *  
 */</span>

<span class="comment">//老的代码   </span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{  
    <span class="keyword">private</span> <span class="variable">$name</span>;  
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$name</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;name = <span class="variable">$name</span>;  
    }  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{  
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;name;  
    }  
}  

<span class="comment">//新代码，开放平台标准接口  </span>
<span class="class"><span class="keyword">interface</span> <span class="title">UserInterface</span> </span>{  
    <span class="function"><span class="keyword">function</span> <span class="title">getUserName</span><span class="params">()</span></span>;  
}  
<span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">UserInterface</span> </span>{  
    <span class="keyword">protected</span> <span class="variable">$user</span>;  
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$user</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;user = <span class="variable">$user</span>;  
    }  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserName</span><span class="params">()</span> </span>{  
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;user-&gt;getName();  
    }  
}  

<span class="variable">$olduser</span> = <span class="keyword">new</span> User(<span class="string">'张三'</span>);  
<span class="keyword">echo</span> <span class="variable">$olduser</span>-&gt;getName().<span class="string">"n"</span>;  
<span class="variable">$newuser</span> = <span class="keyword">new</span> UserInfo(<span class="variable">$olduser</span>);  
<span class="keyword">echo</span> <span class="variable">$newuser</span>-&gt;getUserName().<span class="string">"n"</span>;  

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>注意点：这里的新接口使用了组合方式，UserInfo内部有一个成员变量保存老接口User对象，模块之间是松耦合的，这种结构其实就是组合模式。不要使用继承，虽然UserInfo继承User也能达到同样的目的，但是耦合度高，相互产生影响。</li>
</ul>
<h2 id="桥接模式">桥接模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 桥接模式   
 *   
 */</span>

<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{   
    <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">getJob</span><span class="params">()</span></span>;   
}   

<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJob</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'学生'</span>;   
    }   
}   

<span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJob</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'老师'</span>;   
    }   
}   

<span class="class"><span class="keyword">class</span> <span class="title">BridgeObj</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_person</span>;   

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setPerson</span><span class="params">(<span class="variable">$person</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;_person = <span class="variable">$person</span>;   
    }   

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJob</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_person-&gt;getJob();   
    }   
}   

<span class="variable">$obj</span> = <span class="keyword">new</span> BridgeObj();   
<span class="variable">$obj</span>-&gt;setPerson(<span class="keyword">new</span> Student());   
printf(<span class="string">"本次桥接对象：%sn"</span>, <span class="variable">$obj</span>-&gt;getJob());   
<span class="variable">$obj</span>-&gt;setPerson(<span class="keyword">new</span> Teacher());   
printf(<span class="string">"本次桥接对象：%sn"</span>, <span class="variable">$obj</span>-&gt;getJob());   


<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>将抽象部分与它的实现部分分离，使它们都可以独立变化</li>
</ul>
<h2 id="装饰模式">装饰模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 装饰模式   
 *    
 */</span>

<span class="comment">//产品   </span>
<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{   
    <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">getPermission</span><span class="params">()</span></span>;   
}   
<span class="comment">//被装饰者   </span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPermission</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'公开文档'</span>;   
    }   
}   
<span class="comment">//装饰类   </span>
<span class="class"><span class="keyword">class</span> <span class="title">PermUser</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_user</span>;   
    <span class="keyword">protected</span> <span class="variable">$_special</span> = <span class="string">''</span>;   
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$user</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;_user = <span class="variable">$user</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPermission</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_user-&gt;getPermission() . <span class="variable">$this</span>-&gt;_special;   
    }   
}   
<span class="comment">//装饰类产品   </span>
<span class="class"><span class="keyword">class</span> <span class="title">JavaUser</span> <span class="keyword">extends</span> <span class="title">PermUser</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_special</span> = <span class="string">' java程序'</span>;   
}   
<span class="class"><span class="keyword">class</span> <span class="title">CPlusUser</span> <span class="keyword">extends</span> <span class="title">PermUser</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_special</span> = <span class="string">' c++程序'</span>;   
}   


<span class="variable">$user</span> = <span class="keyword">new</span> User();   
printf(<span class="string">"permission：%sn"</span>, <span class="variable">$user</span>-&gt;getPermission());   
<span class="variable">$user</span> = <span class="keyword">new</span> JavaUser(<span class="variable">$user</span>);   
printf(<span class="string">"permission：%sn"</span>, <span class="variable">$user</span>-&gt;getPermission());   
<span class="variable">$user</span> = <span class="keyword">new</span> CPlusUser(<span class="variable">$user</span>);   
printf(<span class="string">"permission：%sn"</span>, <span class="variable">$user</span>-&gt;getPermission());   


<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>大家想想装饰和继承的区别在哪？</li>
<li>如果是上面的例子，如果用继承，是CPlusUser继承JavaUser还是反过来呢？谁也不知道最终使用者需要哪一种。</li>
<li>在多层关系的情况下，装饰是和顺序无关并且随时增加装饰，而继承只能是特定的顺序，所以装饰模式会更加的灵活。</li>
</ul>
<h2 id="组合模式">组合模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 组合模式   
 *    
 */</span>

<span class="comment">//继承模式   </span>

<span class="class"><span class="keyword">class</span> <span class="title">UserBaseInfo</span> </span>{   
    <span class="keyword">private</span> <span class="variable">$name</span>;   

    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$name</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;name = <span class="variable">$name</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;name;   
    }   
}   
<span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">UserBaseInfo</span> </span>{   
    <span class="keyword">private</span> <span class="variable">$login</span> = <span class="keyword">false</span>;   

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setLogin</span><span class="params">(<span class="variable">$islogin</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;login = <span class="variable">$islogin</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isLogin</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;login;   
    }   
}   

<span class="variable">$user</span> = <span class="keyword">new</span> User(<span class="string">'张三'</span>);   
<span class="variable">$user</span>-&gt;setLogin(<span class="keyword">true</span>);   
<span class="keyword">if</span> (<span class="variable">$user</span>-&gt;isLogin()) {   
    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;getName().<span class="string">"已经登录了n"</span>;   
} <span class="keyword">else</span> {   
    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;getName().<span class="string">"还没有登录n"</span>;   
}   


<span class="comment">//组合模式   </span>

<span class="class"><span class="keyword">class</span> <span class="title">LoginInfo</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$user</span>;   
    <span class="keyword">protected</span> <span class="variable">$login</span> = <span class="keyword">false</span>;   

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setLogin</span><span class="params">(<span class="variable">$user</span>, <span class="variable">$isLogin</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;user = <span class="variable">$user</span>;   
        <span class="variable">$this</span>-&gt;login = <span class="variable">$isLogin</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isLogin</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;login;   
    }   
}   

<span class="variable">$user</span> = <span class="keyword">new</span> User(<span class="string">'张三'</span>);   
<span class="variable">$login</span> = <span class="keyword">new</span> LoginInfo();   
<span class="variable">$login</span>-&gt;setLogin(<span class="variable">$user</span>, <span class="keyword">true</span>);   
<span class="keyword">if</span> (<span class="variable">$login</span>-&gt;isLogin()) {   
    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;getName().<span class="string">"已经登录了n"</span>;   
} <span class="keyword">else</span> {   
    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;getName().<span class="string">"还没有登录n"</span>;   
}   

<span class="comment">//部分可以更换，用继承则不行   </span>
<span class="class"><span class="keyword">class</span> <span class="title">Admin</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$level</span>;   
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$level</span>)</span> </span>{   
        <span class="variable">$this</span>-&gt;level = <span class="variable">$level</span>;   
    }   
    <span class="function"><span class="keyword">function</span> <span class="title">getLevel</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;level;   
    }   
}   
<span class="variable">$admin</span> = <span class="keyword">new</span> Admin(<span class="number">1</span>);   
<span class="variable">$login</span>-&gt;setLogin(<span class="variable">$admin</span>, <span class="keyword">true</span>);   
<span class="keyword">if</span> (<span class="variable">$login</span>-&gt;isLogin()) {   
    printf(<span class="string">"级别为 %d 的管理员已经登录了n"</span>, <span class="variable">$admin</span>-&gt;getLevel());   
} <span class="keyword">else</span> {   
    printf(<span class="string">"级别为 %d 的管理员还没有登录n"</span>, <span class="variable">$admin</span>-&gt;getLevel());   
}   

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>上面的例子分别展示了使用继承和组合来处理新功能，在简单的情况下看似区别不大，但在项目后期越来越复杂的时候组合模式的优势就越来越明显了。</li>
<li>例如上面的登录信息，如果要增加登录次数、最后登录时间、登录ip等信息，登录本身就会变成一个比较复杂的对象。如果以后有新的需求比如好友信息、用户的访问信息等，再要继承的话，用户类就会变得非常庞大，难免各父类之间没有冲突的变量和方法，而外部访问用户类的众多方法也变得很费劲。采用组合模式后，一个类负责一个角色，功能区分非常明显，扩展方便。</li>
</ul>
<h2 id="外观模式">外观模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 外观模式，也叫门面模式   
 *    
 */</span>


<span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPlus</span><span class="params">()</span> </span>{   
        printf(<span class="string">"plus: %sn"</span>, (<span class="number">1</span> + <span class="number">2</span> == <span class="number">3</span> ? <span class="string">'true'</span> : <span class="string">'false'</span>));   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testMinus</span><span class="params">()</span> </span>{   
        printf(<span class="string">"minus: %sn"</span>, (<span class="number">3</span> - <span class="number">2</span> == <span class="number">2</span> ? <span class="string">'true'</span> : <span class="string">'false'</span>));   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testTimes</span><span class="params">()</span> </span>{   
        printf(<span class="string">"times: %sn"</span>, (<span class="number">2</span> * <span class="number">3</span> == <span class="number">6</span> ? <span class="string">'true'</span> : <span class="string">'false'</span>));   
    }   
}   

<span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_operation</span>;   
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{   
        <span class="variable">$this</span>-&gt;_operation = <span class="keyword">new</span> Operation();   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testAll</span><span class="params">()</span> </span>{   
        <span class="variable">$this</span>-&gt;_operation-&gt;testPlus();   
        <span class="variable">$this</span>-&gt;_operation-&gt;testMinus();   
        <span class="variable">$this</span>-&gt;_operation-&gt;testTimes();   
    }   
}   

<span class="comment">//测试用例，测试全部接口   </span>
<span class="variable">$tester</span> = <span class="keyword">new</span> Tester();   
<span class="variable">$tester</span>-&gt;testAll();   


<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>门面模式估计大家在实际代码中都已经使用到了，接口较多时把相似功能的接口封装成一个接口供外部调用，这就是门面模式。</li>
</ul>
<h2 id="单纯享元模式">单纯享元模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>  


<span class="comment">/** 
 * 抽象享元角色 
 */</span>  
<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>{  

    <span class="comment">/** 
     * 示意性方法 
     * <span class="doctag">@param</span> string $state 外部状态 
     */</span>  
    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span></span>;  
}  

<span class="comment">/** 
 * 具体享元角色 
 */</span>  
<span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_intrinsicState</span> = <span class="keyword">null</span>;  

    <span class="comment">/** 
     * 构造方法 
     * <span class="doctag">@param</span> string $state  内部状态 
     */</span>  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;_intrinsicState = <span class="variable">$state</span>;  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">echo</span> <span class="string">'ConcreteFlyweight operation, Intrinsic State = '</span> . <span class="variable">$this</span>-&gt;_intrinsicState  
        . <span class="string">' Extrinsic State = '</span> . <span class="variable">$state</span> . <span class="string">'&lt;br /&gt;'</span>;  
    }  

}  


<span class="comment">/** 
 * 享元工厂角色 
 */</span>  
<span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_flyweights</span>;  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{  
        <span class="variable">$this</span>-&gt;_flyweights = <span class="keyword">array</span>();  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFlyweigth</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>])) {  
            <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>];  
        } <span class="keyword">else</span> {  
            <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>] = <span class="keyword">new</span> ConcreteFlyweight(<span class="variable">$state</span>);  
        }  
    }  

}  

<span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>{  
    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> <span class="params">()</span></span>{  
        <span class="variable">$flyweightFactory</span> = <span class="keyword">new</span> FlyweightFactory();  
        <span class="variable">$flyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="string">'state A'</span>);  
        <span class="variable">$flyweight</span>-&gt;operation(<span class="string">'other state A'</span>);  

        <span class="variable">$flyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="string">'state B'</span>);  
        <span class="variable">$flyweight</span>-&gt;operation(<span class="string">'other state B'</span>);  

    }  
}  



<span class="preprocessor">?&gt;</span>
</code></pre>
<h2 id="复合享元模式">复合享元模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>  

<span class="comment">/** 
 * 复合享元模式 
 *  
 */</span>  

<span class="comment">/** 
 * 抽象享元角色 
 */</span>  
<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>{  

    <span class="comment">/** 
     * 示意性方法 
     * <span class="doctag">@param</span> string $state 外部状态 
     */</span>  
    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span></span>;  
}  

<span class="comment">/** 
 * 具体享元角色 
 */</span>  
<span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_intrinsicState</span> = <span class="keyword">null</span>;  

    <span class="comment">/** 
     * 构造方法 
     * <span class="doctag">@param</span> string $state  内部状态 
     */</span>  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;_intrinsicState = <span class="variable">$state</span>;  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">echo</span> <span class="string">'ConcreteFlyweight operation, Intrinsic State = '</span> . <span class="variable">$this</span>-&gt;_intrinsicState  
        . <span class="string">' Extrinsic State = '</span> . <span class="variable">$state</span> . <span class="string">'&lt;br /&gt;'</span>;  
    }  

}  

<span class="comment">/** 
 * 不共享的具体享元，客户端直接调用 
 */</span>  
<span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_flyweights</span>;  

    <span class="comment">/** 
     * 构造方法 
     * <span class="doctag">@param</span> string $state  内部状态 
     */</span>  
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{  
        <span class="variable">$this</span>-&gt;_flyweights = <span class="keyword">array</span>();  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">foreach</span> (<span class="variable">$this</span>-&gt;_flyweights <span class="keyword">as</span> <span class="variable">$flyweight</span>) {  
            <span class="variable">$flyweight</span>-&gt;operation(<span class="variable">$state</span>);  
        }  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(<span class="variable">$state</span>, Flyweight <span class="variable">$flyweight</span>)</span> </span>{  
        <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>] = <span class="variable">$flyweight</span>;  
    }  

}  

<span class="comment">/** 
* 享元工厂角色 
*/</span>  
<span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>{  

    <span class="keyword">private</span> <span class="variable">$_flyweights</span>;  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{  
        <span class="variable">$this</span>-&gt;_flyweights = <span class="keyword">array</span>();  
    }  

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFlyweigth</span><span class="params">(<span class="variable">$state</span>)</span> </span>{  
        <span class="keyword">if</span> (is_array(<span class="variable">$state</span>)) { <span class="comment">//  复合模式  </span>
            <span class="variable">$uFlyweight</span> = <span class="keyword">new</span> UnsharedConcreteFlyweight();  

            <span class="keyword">foreach</span> (<span class="variable">$state</span> <span class="keyword">as</span> <span class="variable">$row</span>) {  
                <span class="variable">$uFlyweight</span>-&gt;add(<span class="variable">$row</span>, <span class="variable">$this</span>-&gt;getFlyweigth(<span class="variable">$row</span>));  
            }  
            <span class="keyword">return</span> <span class="variable">$uFlyweight</span>;  
        } <span class="keyword">else</span> <span class="keyword">if</span> (is_string(<span class="variable">$state</span>)) {  
            <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>])) {  
                <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>];  
            } <span class="keyword">else</span> {  
                <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_flyweights[<span class="variable">$state</span>] = <span class="keyword">new</span> ConcreteFlyweight(<span class="variable">$state</span>);  
            }  
        } <span class="keyword">else</span> {  
            <span class="keyword">return</span> <span class="keyword">null</span>;  
        }  
    }  

}  

<span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>{  
    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> <span class="params">()</span></span>{  
        <span class="variable">$flyweightFactory</span> = <span class="keyword">new</span> FlyweightFactory();  
        <span class="variable">$flyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="string">'state A'</span>);  
        <span class="variable">$flyweight</span>-&gt;operation(<span class="string">'other state A'</span>);  

        <span class="variable">$flyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="string">'state B'</span>);  
        <span class="variable">$flyweight</span>-&gt;operation(<span class="string">'other state B'</span>);  

        <span class="comment">/* 复合对象*/</span>  
        <span class="variable">$uflyweight</span> = <span class="variable">$flyweightFactory</span>-&gt;getFlyweigth(<span class="keyword">array</span>(<span class="string">'state A'</span>, <span class="string">'state B'</span>));  
        <span class="variable">$uflyweight</span>-&gt;operation(<span class="string">'other state A'</span>);  

    }  
}  


<span class="preprocessor">?&gt;</span>
</code></pre>
<h2 id="代理模式">代理模式</h2><pre><code class="php"><span class="preprocessor">&lt;?php</span>   
<span class="comment">/**   
 *   
 * 代理模式   
 *   
 */</span>

<span class="comment">//内部对象   </span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'张三'</span>;   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getType</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="string">'付费用户'</span>;   
    }   
}   

<span class="comment">//代理接口定义，例如开放平台   </span>
<span class="class"><span class="keyword">interface</span> <span class="title">UserInterface</span> </span>{   
    <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span></span>;   
}   
<span class="comment">//代理对象   </span>
<span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">UserInterface</span> </span>{   
    <span class="keyword">protected</span> <span class="variable">$_user</span>;   
    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>{   
        <span class="variable">$this</span>-&gt;_user = <span class="keyword">new</span> User();   
    }   
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>{   
        <span class="keyword">return</span> <span class="variable">$this</span>-&gt;_user-&gt;getName();   
    }   
}   

<span class="comment">//内部调用   </span>
<span class="variable">$user</span> = <span class="keyword">new</span> User();   
printf(<span class="string">"user name：%sn"</span>, <span class="variable">$user</span>-&gt;getName());   
printf(<span class="string">"user type：%sn"</span>, <span class="variable">$user</span>-&gt;getType());   
<span class="comment">//外部调用   </span>
<span class="comment">// $user = new UserProxy();   </span>
<span class="comment">// printf("user name：%sn", $user-&gt;getName());   </span>
<span class="comment">// printf("user type：%sn", $user-&gt;getType()); //不能访问，及时知道内部对象有这个方法   </span>

<span class="preprocessor">?&gt;</span>
</code></pre>
<ul>
<li>代理模式、适配器模式、门面模式、装饰模式的区别</li>
<li>相同之处：都封装一个内部对象，调用内部对象的方法</li>
<li>不同之处：各自有各自的特性和应用场景，不能相互替代。所以用的时候要仔细分析用那种合适。</li>
</ul>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/19/self/sdk接入文档/">
                sdk接入文档
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-19
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/19/self/sdk接入文档/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/19/self/sdk接入文档/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="接入sdk">接入sdk</h1><p><img src="/img/sdk接入文档/sdk_01.jpg" alt="加入类库"></p>
<p><img src="/img/sdk接入文档/sdk_02.jpg" alt="添加framework"></p>
<p><img src="/img/sdk接入文档/sdk_03.jpg" alt="增加编译参数"></p>
<p><img src="/img/sdk接入文档/sdk_04.jpg" alt="修改参数"></p>
<p><img src="/img/sdk接入文档/sdk_05.jpg" alt="初始化"></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/19/php/http头信息/">
                http头信息
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-19
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/php/">php</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/19/php/http头信息/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/19/php/http头信息/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="常见头信息">常见头信息</h1><ol>
<li><p>Accept：告诉服务器，客户端可以接受的资源类型，可以是一个类型，也可以是多个类型，多个类型间用逗号分隔开<br>特殊的<em>/</em>表示什么类型都可以;q表示希望返回资源的级别，没有的话默认是1，显示写的话通常在类型后用分号分开，往往是一个键值对的形式，如q=0.8。通常服务器会响应一个Content-type的响应头信息。</p>
</li>
<li><p>Accept-Encoding:告诉服务器，客户端支持什么样的压缩算法，可以为一个值或多个值，用逗号分开，常用的压缩算法有gzip。服务器在收到这个字段后，会检查服务器是否支持这个算法，如果支持，就会在发回响应信息前，对资源进行压缩，这样可以减小响应资源的大小。通常服务器会响应一个Content-Encoding:gzip的响应头信息。</p>
</li>
<li><p>Accept-Language:告诉服务器，客户端希望服务器返回的语言格式，对于支持国际话的服务端来说，这个字段很重要，可以通过这个字段，返回不同语言的资源</p>
</li>
<li><p>Cache-Control：这个值告诉服务器客户端希望的缓存策略，如果出现在客户端的请求头中，值往往是max-age=0,告诉服务器，客户端是不缓存服务器资源的</p>
</li>
<li><p>Connection：客户端发送的值往往是keep-alive，这个值告诉服务器自己打开的是一个长tcp连接，服务器接受到这个值后，如果接受这个长连接，就会返回Connection：keep-alive，这样当客户端再有请求发送时，就会重用这个tcp连接；如果不接受长连接就会返回Connection：close。正确的理解keep-alive必须对tcp/ip协议有一定的了解</p>
</li>
<li><p>Cookie：这个值是服务器存储在客户端的数据，cookie是一组键值对，用；分隔开。Cookie有很多重要的知识点，对web开发人员来说极其重要，以后会单独来说明。</p>
</li>
<li><p>Host：这个值对应的是服务器域名或者ip地址。</p>
</li>
<li><p>User-Agent:这个值描述了客户端的详细信息。如果你想写一个简单的爬虫软件，没有这个字段的话，是会被一些服务器拦截的（曾经爬网易的时候就遇到过这个问题）。</p>
</li>
</ol>
<p><strong>上面的这些是chrome请求oschina时的请求头信息，HTTP协议规定的请求头当然远远不止上面说的这些，下面我们再说一些比较常用的请求头：</strong></p>
<ol>
<li><p>Referer:当点击某个网页的的a标签时或者表单提交时，会带上这个值，告诉服务器，这个请求时从哪个页面来的，这样服务器通过这个值就可以统计流量都是从哪里来的，一些广告服务提供商就是靠这个值来收费的。</p>
</li>
<li><p>if-modified-since:这个值是服务器上次响应时请求时发送给客户端的date时间，如果服务器看到这个字段，如果在这段时间没有修改过资源，服务器就会返回304 not modified，如果修改了，就返回资源。</p>
</li>
<li><p>if-none-match:这个值的意义跟if-modified-since一样，也是一个条件请求，但这个值比上面的值有增强效果，因为文件即使修改时间变了，不一定说明资源变了。</p>
</li>
<li><p>Range：可以告诉服务器，只请求资源的一段，值可以是这样bytes=100-1000，通过这个，可以做到断点下载。</p>
</li>
<li><p>Authorization：当服务器资源需要权限才能访问时，客户端会带上这个请求头信息，将认证信息通过这个字段传递给服务器，通常这个值会采用base64编码，将username:password类型的值编码后通过网络传递给服务器，因为base64编码是可逆的，不够安全，所以现在的安全控制很少用这种方式，一般是用https。</p>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/16/apple/apple证书详解/">
                apple证书详解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-16
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/object-c/">object-c</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/16/apple/apple证书详解/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/16/apple/apple证书详解/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>刚接触iOS开发的人难免会对苹果的各种证书、配置文件等不甚了解，可能你按照网上的教程一步一步的成功申请了真机调试，但是还是对其中的缘由一知半解。这篇文章就对Certificate、Provisioning Profile等做个总结。</p>
<h1 id="概念介绍">概念介绍</h1><p>如果你拥有一个开发者账户的话，在iOS Dev Center打开Certificates, Indentifiers &amp; Profiles，你就可以看到如下的列表：</p>
<p><img src="/img/apple证书详解/1.png" alt="apple证书"></p>
<p>Profile Portal改版有一段时间了，改版之后的结构比以前更清晰明了，易于理解和管理。</p>
<p>上面的列表就包含了开发、调试和发布iOS应用程序所需的所有内容：Certificates、Identifiers、Devices、Provisioning Profiles。下面将一一解释这几个东东。</p>
<h2 id="Certificate">Certificate</h2><p>证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting的Code Signing Identity中，你可以设置用于为代码签名的证书。 </p>
<p>众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 </p>
<p><img src="/img/apple证书详解/2.png" alt="apple证书"></p>
<p>证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发应用程序（根据证书种类有不同作用），下面是证书的分类信息：（括号内为证书有效期）</p>
<blockquote>
<p>（注：不同类型的开发者账户所能创建的证书种类不同，关于开发者账户的对比和InHouse证书相关的内容，请见我的另一篇文章）</p>
</blockquote>
<ul>
<li>Development<ul>
<li>App Development (1年)：用来开发和真机调试应用程序。</li>
<li>Push Development (1年)：用来调试Apple Push Notification</li>
</ul>
</li>
<li>Production<ul>
<li>In-House and Ad Hoc (3年)：用来发布In-House和AdHoc的应用程序。</li>
<li>App Store ：用来发布提交App Store的应用程序。</li>
<li>MDM CSR</li>
<li>Push Production (1年)：用来在发布版本中使用Apple Push Notification。</li>
<li>Pass Type ID Certificate</li>
<li>Website Push ID Certificate</li>
</ul>
</li>
</ul>
<p>有一些类型的证书我没有使用过，所以也不了解具体的作用。</p>
<h3 id="App_ID">App ID</h3><p>App ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种： </p>
<ul>
<li>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。</li>
<li>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。</li>
</ul>
<p>每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。下面是目前所有可选的服务和相应的配置要求。</p>
<p><img src="/img/apple证书详解/3.png" alt="apple证书"></p>
<p>如果你的App使用上述的任何一种service，就要按照要求去配置。</p>
<h3 id="Device">Device</h3><p>Device最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。</p>
<p>每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。</p>
<p><strong>举例</strong></p>
<ol>
<li><p>假如第一年，你增加了70个设备，同时删除了10个设备，这个时候，虽然你的设备数是60，但是可用的增加测试机的名额却只有30个了。</p>
</li>
<li><p>到了第二年，你续费了开发者身份，在你第一次登陆进去后，你可以看到你的可用设备恢复成 100 – 60 = 40个了。这个时候，你可以选择删除一些设备，例如你又删除了20个设备，这样你的名额数变成60个。之后你增加了一个设备，因为你选择了增加新设备，苹果认为你已经放弃删除设备以恢复设备数的机会，这样，你的名额就固定成59个。以后删除设备都不会增加新名额了，直到你的下一个membership year开始时才又会有这样的机会来删除设备释放名额。</p>
</li>
</ol>
<p>那如果万一我的设备数达到上限，我又急需要增加新设备怎么办呢？</p>
<p>具体做法是访问：<a href="https://developer.apple.com/contact/" target="_blank" rel="external">https://developer.apple.com/contact/</a>，点击 Program Benefits， 然后在新出来的提交界面中将需求填上。之后苹果会发邮件过来告诉你处理结果，可能需要打电话过去和他们沟通一些细节。在沟通完成后，苹果就可以立即帮助你状态修改到“可删除设备来增加测试设备名额”。这样，你就可以选择性的删除一些不需要的设备来释放一些名额了。</p>
<h2 id="Provisioning_Profile">Provisioning Profile</h2><p>一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。</p>
<p>试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。</p>
<p>例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。</p>
<p><img src="/img/apple证书详解/4.png" alt="apple证书"></p>
<p>如上所述，在一台设备上运行应用程序的过程如下：</p>
<p><img src="/img/apple证书详解/5.png" alt="apple证书"></p>
<p>与证书一样，Provisioning Profile也分为Development和Distribution两种：</p>
<blockquote>
<p>（注：前面提到不同账户类型所能创建的证书种类不同，显然Profile文件的种类是和你所能创建的证书种类相关的）</p>
</blockquote>
<ul>
<li>Development (1年)</li>
<li>Distribution (1年)<ul>
<li>In House</li>
<li>Ad Hoc</li>
<li>App Store</li>
</ul>
</li>
</ul>
<p>In House 与Ad Hoc的不同之处在于：In House没有设备数量限制，而Ad Hoc是用来测试用的，Ad Hoc的包只能运行在该账户内已登记的可用设备上，显然是有最多100个设备的数量限制。所以这两种Provisioning Profile文件的区别就在于其中的设备限制不一样而已，而他们所使用的Certificate是相同的。    </p>
<h1 id="开发/发布流程">开发/发布流程</h1><p>了解了上面的概念，再来看开发及发布流程就非常简单了，而且相信你不用看教程也能一步步完成所有的操作了。</p>
<h2 id="开发/真机调试流程">开发/真机调试流程</h2><p>根据上面的介绍，可以知道进行Development主要有以下几个步骤：</p>
<ul>
<li>申请证书</li>
<li>加入设备</li>
<li>生成Provisioning Profile</li>
<li>设置Xcode Code Sign Identifer</li>
</ul>
<p>事实上第三步通常是不需要的，因为我们通常都是用Xcode生成和管理的iOS Team Provisioning Profile来进行开发，因为它非常方便，所以不需要自己手动生成Provisioning Profile。</p>
<p>iOS Team Provisioning Profile是第一次使用Xcode添加设备时，Xcode自动生成的，它包含了Xcode生成的一个Wildcard App ID（*，匹配所有应用程序），账户里面所有的Devices和所有Development Certificates，如下图所示。因此，team中的所有成员都可以使用这个iOS Team Provisioning Profile在team中的所有设备上调试所有的应用程序。并且当有新设备添加进来时，Xcode会更新这个文件。</p>
<p><img src="/img/apple证书详解/6.png" alt="apple证书"></p>
<h2 id="发布流程">发布流程</h2><p>网上有很多关于发布App Store的流程，我就不缀述了，不过根据上面的概念介绍，不管是App Store、In-House还是Ad-Hoc，打包流程都是差不多的，都包括了以下几个关键步骤：</p>
<ul>
<li>创建发布证书</li>
<li>创建App ID</li>
<li>创建对应的Provisioning Profile文件</li>
<li>设备Bundle ID和App ID一致</li>
<li>设置Xcode Code Sign Identifer，选择合适的Profile和证书进行签名，打包</li>
</ul>
<p>以上就是对证书、Provisioning Profile、App ID等的介绍。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/15/object-c/触摸事件/">
                触摸事件处理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-15
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/ios/">ios</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/15/object-c/触摸事件/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/15/object-c/触摸事件/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>iphone/ipad无键盘的设计是为屏幕争取更多的显示空间，大屏幕在观看图片、文字、视频等方面为用户带来了更好的用户体验。而触摸屏幕是iOS设备接受用户输入的主要方式，包括单击、双击、拨动以及多点触摸等，这些操作都会产生触摸事件。</p>
<p>在Cocoa中，代表触摸对象的类是<code>UITouch</code>。当用户触摸屏幕后，就会产生相应的事件，所有相关的UITouch对象都被包装在事件中，被程序交由特定的对象来处理。UITouch对象直接包括触摸的详细信息。</p>
<h2 id="UITouch类中包含5个属性：">UITouch类中包含5个属性：</h2><ol>
<li>window：触摸产生时所处的窗口。由于窗口可能发生变化，当前所在的窗口不一定是最开始的窗口。</li>
<li>view:触摸产生时所处的视图。由于视图可能发生变化，当前视图也不一定时最初的视图。</li>
<li>tapCount：轻击（Tap）操作和鼠标的单击操作类似，tapCount表示短时间内轻击屏幕的次数。因此可以根据tapCount判断单击、双击或更多的轻击。</li>
<li>timestamp：时间戳记录了触摸事件产生或变化时的时间。单位是秒。</li>
<li><p>phase：触摸事件在屏幕上有一个周期，即触摸开始、触摸点移动、触摸结束，还有中途取消。而通过phase可以查看当前触摸事件在一个周期中所处的状态。phase是<code>UITouchPhase</code>类型的，这是一个枚举配型，包含了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITouchPhaseBegan</span>（触摸开始）</span><br><span class="line"><span class="built_in">UITouchPhaseMoved</span>（接触点移动）</span><br><span class="line"><span class="built_in">UITouchPhaseStationary</span>（接触点无移动）</span><br><span class="line"><span class="built_in">UITouchPhaseEnded</span>（触摸结束）</span><br><span class="line"><span class="built_in">UITouchPhaseCancelled</span>（触摸取消）</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="UITouch类中包含如下成员函数：">UITouch类中包含如下成员函数：</h2><ul>
<li><p><code>- (CGPoint)locationInView:(UIView *)view</code>：函数返回一个CGPoint类型的值，表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置。</p>
</li>
<li><p><code>- (CGPoint)previousLocationInView:(UIView *)view</code>：该方法记录了前一个坐标值，函数返回也是一个CGPoint类型的值， 表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置。</p>
</li>
</ul>
<p>当手指接触到屏幕，不管是单点触摸还是多点触摸，事件都会开始，直到用户所有的手指都离开屏幕。期间所有的UITouch对象都被包含在UIEvent事件对象中，由程序分发给处理者。事件记录了这个周期中所有触摸对象状态的变化。</p>
<p>只要屏幕被触摸，系统就会报若干个触摸的信息封装到UIEvent对象中发送给程序，由管理程序UIApplication对象将事件分发。一般来说，事件将被发给主窗口，然后传给第一响应者对象(<code>FirstResponder</code>)处理。</p>
<p>关于响应者的概念，通过以下几点说明：</p>
<ul>
<li><p>响应者对象（Response object）</p>
<p>响应者对象就是可以响应事件并对事件作出处理。在iOS中，存在UIResponder类，它定义了响应者对象的所有方法。UIApplication、UIView等类都继承了UIResponder类，UIWindow和UIKit中的控件因为继承了UIView，所以也间接继承了UIResponder类，这些类的实例都可以当作响应者。</p>
</li>
<li><p>第一响应者（First responder）</p>
<p>当前接受触摸的响应者对象被称为第一响应者，即表示当前该对象正在与用户交互，它是响应者链的开端。</p>
</li>
<li><p>响应者链（Responder chain）</p>
<p>响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者（next responder）。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow对象）再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>
</li>
<li><p>管理事件分发</p>
<p>视图对触摸事件是否需要作处回应可以通过设置视图的<code>userInteractionEnabled</code>属性。默认状态为<code>YES</code>，如果设置为<code>NO</code>，可以阻止视图接收和分发触摸事件。除此之外，当视图被隐藏（<code>setHidden：YES</code>）或者透明（<code>alpha</code>值为0）也不会收事件。不过这个属性只对视图有效，如果想要整个程序都步响应事件，可以调用<code>UIApplication</code>的<code>beginIngnoringInteractionEvents</code>方法来完全停止事件接收和分发。通过<code>endIngnoringInteractionEvents</code>方法来恢复让程序接收和分发事件。</p>
</li>
</ul>
<p>如果要让视图接收多点触摸，需要设置它的<code>multipleTouchEnabled</code>属性为<code>YES</code>，默认状态下这个属性值为<code>NO</code>，即视图默认不接收多点触摸。</p>
<h2 id="如何处理用户的触摸事件">如何处理用户的触摸事件</h2><p>*首先触摸的对象是视图，而视图的类UIView继承了UIRespnder类，但是要对事件作出处理，还需要重写UIResponder类中定义的事件处理函数。根据不通的触摸状态，程序会调用相应的处理函数，这些函数包括以下几个：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当手指接触屏幕时，就会调用touchesBegan:withEvent方法；</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesBegan:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指在屏幕上移时，动就会调用touchesMoved:withEvent方法；</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesMoved:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当手指离开屏幕时，就会调用touchesEnded:withEvent方法；</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesEnded:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当触摸被取消（比如触摸过程中被来电打断），就会调用touchesCancelled:withEvent方法。</span></span><br><span class="line">-(<span class="typename">void</span>)<span class="string">touchesCancelled:</span>(NSSet *)touches <span class="string">withEvent:</span>(UIEvent *)event;</span><br></pre></td></tr></table></figure>
<p>而这几个方法被调用时，正好对应了<code>UITouch</code>类中<code>phase</code>属性的4个枚举值。</p>
<p>上面的四个事件方法，在开发过程中并不要求全部实现，可以根据需要重写特定的方法。对于这4个方法，都有两个相同的参数：<code>NSSet</code>类型的<code>touches</code>和<code>UIEvent</code>类型的<code>event</code>。其中touches表示触摸产生的所有<code>UITouch</code>对象，而event表示特定的事件。因为<code>UIEvent</code>包含了整个触摸过程中所有的触摸对象，因此可以调用<code>allTouches</code>方法获取该事件内所有的触摸对象，也可以调用<code>touchesForVIew</code>：或者<code>touchesForWindows</code>：取出特定视图或者窗口上的触摸对象。在这几个事件中，都可以拿到触摸对象，然后根据其位置，状态，时间属性做逻辑处理。</p>
<p>例如:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch =  [touches anyObject];</span><br><span class="line">    <span class="keyword">if</span>(touch<span class="variable">.tapCount</span> == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子说明在触摸手指离开后，根据tapCount点击的次数来设置当前视图的背景色。不管时一个手指还是多个手指，轻击操作都会使每个触摸对象的tapCount加1，由于上面的例子不需要知道具体触摸对象的位置或时间等，因此可以直接调用touches的anyObject方法来获取任意一个触摸对象然后判断其tapCount的值即可。</p>
<p>检测tapCount可以放在touchesBegan也可以touchesEnded，不过一般后者跟准确，因为touchesEnded可以保证所有的手指都已经离开屏幕，这样就不会把轻击动作和按下拖动等动作混淆。</p>
<p>轻击操作很容易引起歧义，比如当用户点了一次之后，并不知道用户是想单击还是只是双击的一部分，或者点了两次之后并不知道用户是想双击还是继续点击。为了解决这个问题，一般可以使用“<strong>延迟调用</strong>”函数。</p>
<p>例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch =  [touches anyObject];</span><br><span class="line">    <span class="keyword">if</span>(touch<span class="variable">.tapCount</span> == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(setBackground:) withObject:[<span class="built_in">UIColor</span> blueColor] afterDelay:<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示在第一次轻击之后，没有直接更改视图的背景属性，而是通过<code>performSelector：withObject：afterDelay</code>：方法设置2秒中后更改。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch =  [touches anyObject];</span><br><span class="line">    <span class="keyword">if</span>(touch<span class="variable">.tapCount</span> == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(setBackground:) object:[<span class="built_in">UIColor</span> redColor]];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双击就是两次单击的组合，因此在第一次点击的时候，设置背景色的方法已经启动，在检测到双击的时候先要把先前对应的方法取消掉，可以通过调用NSObject类的<code>cancelPreviousPerformRequestWithTarget:selector:object</code>方法取消指定对象的方法调用，然后调用双击对应的方法设置背景色为红色。</p>
<p>下面举个例子创建可以拖动的视图，这个主要通过触摸对象的位置坐标来实现。因此调用触摸对象的locationInView：方法即可。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGPoint</span> originalLocation;</span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    originalLocation = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> currentLocation = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.x</span> += currentLocation<span class="variable">.x</span>-originalLocation<span class="variable">.x</span>;</span><br><span class="line">    frame<span class="variable">.origin</span><span class="variable">.y</span> += currentLocation<span class="variable">.y</span>-originalLocation<span class="variable">.y</span>;   </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span> = frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先在<code>touchesBegan</code>中通过<code>[touch locationInView:self.view]</code>获取手指触摸在当前视图上的位置，用<code>CGPoint</code>变量记录，然后在手指移动事件touchesMoved方法中获取触摸对象当前位置，并通过于与原始位置的差值计算出移动偏移量，再设置当前视图的位置。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/10/cpp/stl_map与boost_unordered_map/">
                STL map与Boost unordered_map
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/10/cpp/stl_map与boost_unordered_map/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/10/cpp/stl_map与boost_unordered_map/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="STL_map与Boost_unordered_map">STL map与Boost unordered_map</h1><p>今天看到 boost::unordered_map， 它与 stl::map的区别就是，stl::map是按照operator&lt;比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator&lt; 定义的大小排序。</p>
<p>而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对unordered_map进行遍历，结果是无序的。</p>
<p>用法的区别就是，stl::map 的key需要定义operator&lt; 。 而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator&lt; 或者hash_value()了。 </p>
<p>最后，说，当不需要结果排好序时，最好用unordered_map。</p>
<p>其实，stl::map对于与java中的TreeMap，而boost::unordered_map对应于java中的HashMap。 </p>
<h2 id="stl::map">stl::map</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	int age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">person</span>(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;name =  name;</span><br><span class="line">		this-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const <span class="keyword">person</span>&amp; p) const</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;age &lt; p.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">person</span>,int&gt; m;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">person</span> p1(<span class="string">"Tom1"</span>,20);</span><br><span class="line">	<span class="keyword">person</span> p2(<span class="string">"Tom2"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p3(<span class="string">"Tom3"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p4(<span class="string">"Tom4"</span>,23);</span><br><span class="line">	<span class="keyword">person</span> p5(<span class="string">"Tom5"</span>,24);</span><br><span class="line">	m.insert(make_pair(p3, 100));</span><br><span class="line">	m.insert(make_pair(p4, 100));</span><br><span class="line">	m.insert(make_pair(p5, 100));</span><br><span class="line">	m.insert(make_pair(p1, 100));</span><br><span class="line">	m.insert(make_pair(p2, 100));</span><br><span class="line">	</span><br><span class="line">	for(map&lt;<span class="keyword">person</span>, int&gt;::iterator iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;iter-&gt;first.name&lt;&lt;<span class="string">"\t"</span>&lt;&lt;iter-&gt;first.age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Tom1    20</span><br><span class="line">Tom3    22</span><br><span class="line">Tom4    23</span><br><span class="line">Tom5    24</span><br></pre></td></tr></table></figure>
<blockquote>
<p>operator&lt;的重载一定要定义成const。因为map内部实现时调用operator&lt;的函数好像是const。</p>
<p>由于operator&lt;比较的只是age,所以因为Tom2和Tom3的age相同，所以最终结果里面只有Tom3，没有Tom2</p>
</blockquote>
<h2 id="boost::unordered_map">boost::unordered_map</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;boost/unordered_map.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	int age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">person</span>(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;name =  name;</span><br><span class="line">		this-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator== (const <span class="keyword">person</span>&amp; p) const</span><br><span class="line">	&#123;</span><br><span class="line">		return name==p.name &amp;&amp; age==p.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">size_t hash_value(const <span class="keyword">person</span>&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	size_t seed = 0;</span><br><span class="line">	boost::hash_combine(seed, boost::hash_value(p.name));</span><br><span class="line">	boost::hash_combine(seed, boost::hash_value(p.age));</span><br><span class="line">	return seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	typedef boost::unordered_map&lt;<span class="keyword">person</span>,int&gt; umap;</span><br><span class="line">	umap m;</span><br><span class="line">	<span class="keyword">person</span> p1(<span class="string">"Tom1"</span>,20);</span><br><span class="line">	<span class="keyword">person</span> p2(<span class="string">"Tom2"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p3(<span class="string">"Tom3"</span>,22);</span><br><span class="line">	<span class="keyword">person</span> p4(<span class="string">"Tom4"</span>,23);</span><br><span class="line">	<span class="keyword">person</span> p5(<span class="string">"Tom5"</span>,24);</span><br><span class="line">	m.insert(umap::value_type(p3, 100));</span><br><span class="line">	m.insert(umap::value_type(p4, 100));</span><br><span class="line">	m.insert(umap::value_type(p5, 100));</span><br><span class="line">	m.insert(umap::value_type(p1, 100));</span><br><span class="line">	m.insert(umap::value_type(p2, 100));</span><br><span class="line">	</span><br><span class="line">	for(umap::iterator iter = m.begin(); iter != m.end(); iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;iter-&gt;first.name&lt;&lt;<span class="string">"\t"</span>&lt;&lt;iter-&gt;first.age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Tom1    20</span><br><span class="line">Tom5    24</span><br><span class="line">Tom4    23</span><br><span class="line">Tom2    22</span><br><span class="line">Tom3    22</span><br></pre></td></tr></table></figure>
<blockquote>
<p>必须要自定义operator==和hash_value。 重载operator==是因为，如果两个元素的hash_value的值相同，并不能断定这两个元素就相同，必须再调用operator==。 当然，如果hash_value的值不同，就不需要调用operator==了。</p>
</blockquote>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/08/cpp/std_function和std_bind/">
                c++11中的bind和function
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-08
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/08/cpp/std_function和std_bind/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/08/cpp/std_function和std_bind/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="c++11中的bind和function">c++11中的bind和function</h1><h2 id="std::function">std::function</h2><p>它是函数、函数对象、函数指针、和成员函数的包装器，可以容纳任何类型的函数对象，函数指针，引用函数，成员函数的指针。<br>以统一的方式处理函数、函数对象、函数指针、和成员函数。</p>
<p>允许保存和延迟执行函数。</p>
<ul>
<li>函数和成员函数作为function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">G</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">H</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f = G; <span class="comment">//全局函数</span></span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f <span class="number">1</span>= <span class="built_in">std</span>::bind(&amp;A::H, a); <span class="comment">//成员函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以用function取代函数指针。因为它可以保存函数延迟执行，所以比较适合作为回调函数，也可以把它看做类似于c#中特殊的委托，只有一个成员的委托。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">A(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&amp; f):m_callback(f)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">m_callback();<span class="comment">//回调到上层</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; m_callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>function还可以作为函数入参，这样可以在函数外部控制函数的内部行为了，让我们的函数变得更加灵活。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)</span>&gt;&amp; f)</span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">f(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x+<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFoo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(G, <span class="built_in">std</span>::placeholders::_1); </span><br><span class="line">Foo(<span class="number">4</span>, f);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Foo函数外面更改f的行为</span></span><br><span class="line">f = <span class="built_in">std</span>::bind(H, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">Foo(<span class="number">4</span>, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std::bind绑定器">std::bind绑定器</h2><ul>
<li>将函数、成员函数和闭包转成function函数对象</li>
<li>将多元(n&gt;1)函数转成一元函数或者(n-1)元函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="comment">//绑定全局函数</span></span><br><span class="line"><span class="keyword">auto</span> f11 = <span class="built_in">std</span>::bind(H, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"><span class="keyword">auto</span>的类型实际上是<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定带参数的成员函数</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">char</span>*, <span class="keyword">int</span>)&gt; f = <span class="built_in">std</span>::bind(&amp;ReadHandler::ConnectPreProcess, <span class="keyword">this</span>, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三元函数转换成一元函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="comment">// 绑定f()函数调用的第二个和第三个参数，</span></span><br><span class="line"><span class="comment">// 返回一个新的函数对象为ff，它只带有一个int类型的参数</span></span><br><span class="line"><span class="keyword">auto</span> ff = bind(f, _1, ‘c’, <span class="number">1.2</span>);    </span><br><span class="line"><span class="keyword">int</span> x = ff(<span class="number">7</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>bind简化和增强bind1st和bind2nd</li>
</ul>
<p>其实bind简化和增强了之前标准库中bind1st和bind2nd，它完全可以替代bind1s和bind2st，并且能组合函数。我们知道bind1st和bind2nd将一个二元算子转换成一个一元算子。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素值大于10的元素的个数</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, std::bind1st<span class="params">(less&lt;int&gt;<span class="params">()</span>, <span class="number">10</span>)</span>)</span>;</span><br><span class="line"><span class="comment">//查找元素之小于10的元素</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, std::bind2nd<span class="params">(less&lt;int&gt;<span class="params">()</span>, <span class="number">10</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>本质上是对一个二元函数less<int>的调用，但是它却要分别用bind1st和bind2nd，而且还要想想到底是用bind1st还是bind2nd，用起来感觉不方便。现在用bind，就可以以统一的方式去实现了。</int></p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找元素值大于10的元素的个数</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, bind<span class="params">(less&lt;int&gt;<span class="params">()</span>, <span class="number">10</span>, _1)</span>)</span>;</span><br><span class="line"><span class="comment">//查找元素之小于10的元素</span></span><br><span class="line">int count = count_if<span class="params">(coll.begin<span class="params">()</span>, coll.end<span class="params">()</span>, bind<span class="params">(less&lt;int&gt;<span class="params">()</span>, _1, <span class="number">10</span>)</span>)</span>;</span><br><span class="line">这样我就不用关心到底是用bind1st还是bind2nd了，只要用bind就都搞定了。</span><br></pre></td></tr></table></figure>
<ul>
<li>bind函数组合</li>
</ul>
<p>bind的还有一个强大之处就是函数组合。假设我们要找出集合中大于5小于10的元素个数怎么做呢？我们需要一个逻辑与才能做到类似于： </p>
<p><code>std::bind(std::logical_and&lt;bool&gt;(),_1,_2);</code></p>
<p>然后，我们需要另一个谓词来回答 _1 是否大于5。</p>
<p><code>std::bind(std::greater&lt;int&gt;(),_1,5);</code></p>
<p>然后，我们还需要另一个谓词来回答 _1 是否小于等于10。</p>
<p><code>std::bind(std::less_equal&lt;int&gt;(),_1,10);</code></p>
<p>最后，我们需要把它们两个用逻辑与合起来，就象这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找集合中大于5小于10的元素个数</span></span><br><span class="line"><span class="keyword">auto</span> f = bind(<span class="built_in">std</span>::logical_and&lt;<span class="keyword">bool</span>&gt;(), bind(<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">5</span>), bind(<span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">int</span> count = count_if(coll.begin(), coll.end(), f);</span><br></pre></td></tr></table></figure>
<p>c++11中推出function是为了泛化函数对象，函数指针，引用函数，成员函数的指针，让我们可以按更统一的方式写出更加泛化的代码；推出bind是为了替换和增强之前标准库的bind1st和bind2st，让我们的用起来更方便！</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/07/cpp/std_find,std_find_if/">
                std::find,std::find_if
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/07/cpp/std_find,std_find_if/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/07/cpp/std_find,std_find_if/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="std::find,std::find_if">std::find,std::find_if</h1><ul>
<li>STL的find，find_if函数提供了一种对数组、STL容器进行查找的方法。使用该函数，需 #include <algorithm>,我们查找一个list中的数据，通常用find()，例如：</algorithm></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line">	lst.push_back(<span class="number">10</span>);</span><br><span class="line">	lst.push_back(<span class="number">20</span>);</span><br><span class="line">	lst.push_back(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(lst.begin(), lst.end(), <span class="number">10</span>); <span class="comment">// 查找list中是否有元素“10”</span></span><br><span class="line">	<span class="keyword">if</span> (it != lst.end()) <span class="comment">// 找到了</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// do something </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">// 没找到</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>那么，如果容器里的元素是一个类呢？例如，有list<cperson> ，其中CPerson类定义如下：</cperson></li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CPerson(<span class="keyword">void</span>); ~CPerson(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么如何用find()函数进行查找呢？这时，我们需要提供一个判断两个CPerson对象“相等”的定义，find()函数才能从一个list中找到与指定的CPerson“相等”的元素。</p>
<p>这个“相等”的定义，是通过重载“==”操作符实现的，我们在CPerson类中添加一个方法，定义为：</p>
<p><code>bool operator==(const CPerson &amp;rhs) const;</code></p>
<p>实现为：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="attribute">CPerson</span>::operator==(<span class="keyword">const</span> CPerson &amp;rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (id == rhs.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="pi">//然后我们就可以这样查找（假设list中已经有了若干CPerson对象）了：</span><br><span class="line">list&lt;CPerson&gt; lst;</span><br><span class="line">//</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span></span><br><span class="line"><span class="pi">// 向lst中添加元素，此处省略</span><br><span class="line">//</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span></span><br><span class="line">CPerson cp_to_find; <span class="pi">// 要查找的对象</span><br><span class="line">cp_to_find.age = 50;</span><br><span class="line">list&lt;CPerson&gt;::iterator it = find(list.begin(), list.end(), cp_to_find); //</span> 查找</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">it</span> != lst.end()) <span class="pi">// 找到了</span><br><span class="line">&#123;</span><br><span class="line">	//</span> <span class="keyword">do</span> something </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="pi">// 没找到</span><br><span class="line">&#123;</span><br><span class="line">	//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有人说，如果我有自己定义的“相等”呢？例如，有一个list<cperson*>，这个list中的每一个元素都是一个对象的指针，我们要在这个list中查找具有指定age的元素，找到的话就得到对象的指针。</cperson*></li>
</ul>
<p>这时候，你不再能像上面的例子那样做，我们需要用到find_if函数，并自己指定predicate function（即find_if函数的第三个参数，请查阅STL手册）。先看看find_if函数的定义：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">InputIterator</span>, class <span class="type">Predicate</span>&gt;</span><br><span class="line">   <span class="type">InputIterator</span> find_if(<span class="type">InputIterator</span> _First, <span class="type">InputIterator</span> _Last, <span class="type">Predicate</span> _Pred);</span><br><span class="line"><span class="type">Parameters</span></span><br><span class="line">_First</span><br><span class="line"><span class="type">An</span> input <span class="keyword">iterator</span> addressing the position <span class="keyword">of</span> the first element <span class="keyword">in</span> the <span class="type">range</span> </span><br><span class="line">to be searched.</span><br><span class="line"></span><br><span class="line">_Last</span><br><span class="line"><span class="type">An</span> input <span class="keyword">iterator</span> addressing the position one past the final element <span class="keyword">in</span> the </span><br><span class="line"><span class="type">range</span> to be searched.</span><br><span class="line"></span><br><span class="line">_Pred</span><br><span class="line"><span class="type">User</span>-defined predicate function <span class="keyword">object</span> that defines the condition to be </span><br><span class="line">satisfied by the element being searched <span class="keyword">for</span>. A predicate takes single argument </span><br><span class="line"><span class="keyword">and</span> returns <span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>.</span><br></pre></td></tr></table></figure>
<p>我们在CPerson类外部定义这样一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">finder_t</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">finder_t</span>(<span class="keyword">int</span> n): age(n)	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(CPerson *p)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (age == p-&gt;age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>	age;</span><br><span class="line">&#125;<span class="keyword">finder_t</span>;</span><br></pre></td></tr></table></figure>
<p>然后就可以利用find_if函数来查找了：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list&lt;CPerson*&gt; lst;</span><br><span class="line"><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">//</span><br><span class="line">//</span> 向lst中添加元素，此处省略</span><br><span class="line"><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">////</span><span class="pi">//</span><br><span class="line">list&lt;CPerson*&gt;::iterator it = find_if(lst.begin(), lst.end(), finder_t(50));	//</span> 查找年龄为<span class="number">50</span>的人</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">it</span> != lst.end())	<span class="pi">// 找到了</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; "Found person with age : " &lt;&lt; (*it)-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line">else	//</span> 没找到</span><br><span class="line">&#123;</span><br><span class="line">	<span class="pi">// do something</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/06/cpp/share_ptr/">
                share_ptr
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-06
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/06/cpp/share_ptr/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/06/cpp/share_ptr/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="share_ptr">share_ptr</h1><ul>
<li>shared_ptr是一个最像指针的”智能指针”，是boost.smart_ptr库中最有价值、最重要的组成部分，也是最有用的，Boost库的许多组件—甚至还包括其他一些领域的智能指针都使用了shared_ptr。抱歉，我实在想不出什么更恰当的词汇来形容它在软件开发中的重要性。再强调一遍，shared_ptr非常有价值、非常重要、非常有用。</li>
</ul>
<ul>
<li><p>shared_ptr与scoped_ptr一样包装了new操作符在堆上分配的动态对象，但它实现的是引用计数型的智能指针 ，可以被自由地拷贝和赋值，在任意的地方共享它，当没有代码使用（引用计数为0）它时才删除被包装的动态分配的对象。shared_ptr也可以安全地放到标准容器中，并弥补了auto_ptr因为转移语义而不能把指针作为STL容器元素的缺陷。</p>
</li>
<li><p>在C++历史上曾经出现过无数的引用计数型智能指针实现，但没有一个比得上boost::shared_ptr，在过去、现在和将来，它都是最好的。</p>
</li>
</ul>
<h2 id="shared_ptr的线程安全性"><strong>shared_ptr的线程安全性</strong></h2><ul>
<li>shared_ptr 本身不是 100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为 shared_ptr 有两个数据成员，读写操作不能原子化。根据文档，shared_ptr 的线程安全级别和内建类型、标准库容器、string 一样，即：</li>
</ul>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个 <span class="annotation">shared</span><span class="number">_p</span>tr 实体可被多个线程同时读取；</span><br><span class="line">两个的 <span class="annotation">shared</span><span class="number">_p</span>tr 实体可以被两个线程同时写入，“析构”算写操作；</span><br><span class="line">如果要从多个线程读写同一个 <span class="annotation">shared</span><span class="number">_p</span>tr 对象，那么需要加锁。</span><br></pre></td></tr></table></figure>
<h2 id="shared_ptr用法"><strong>shared_ptr用法</strong></h2><p>示例一：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp<span class="params">(new int<span class="params">(<span class="number">10</span>)</span>)</span>;                <span class="comment">//一个指向整数的shared_ptr  </span></span><br><span class="line">assert<span class="params">(sp.unique<span class="params">()</span>)</span>;                            <span class="comment">//现在shared_ptr是指针的唯一持有者   </span></span><br><span class="line">shared_ptr&lt;int&gt; sp2 = sp;                       <span class="comment">//第二个shared_ptr,拷贝构造函数   </span></span><br><span class="line">assert<span class="params">(sp == sp2 &amp;&amp; sp.use_count<span class="params">()</span> == <span class="number">2</span>)</span>;		<span class="comment">//两个shared_ptr相等,指向同一个对象,引用计数为2  </span></span><br><span class="line"><span class="built_in">*</span>sp2 = <span class="number">100</span>;										<span class="comment">//使用解引用操作符修改被指对象  </span></span><br><span class="line">assert<span class="params">(*sp == <span class="number">100</span>)</span>;								<span class="comment">//另一个shared_ptr也同时被修改   </span></span><br><span class="line">sp.reset<span class="params">()</span>;                                     <span class="comment">//停止shared_ptr的使用  </span></span><br><span class="line">assert<span class="params">(!sp)</span>;                                    <span class="comment">//sp不再持有任何指针(空指针)</span></span><br></pre></td></tr></table></figure>
<p>示例一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> shared                                    <span class="comment">//一个拥有shared_ptr的类  </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:      </span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p;                          <span class="comment">//shared_ptr成员变量  </span></span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">	shared(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p_):p(p_)&#123;&#125;          <span class="comment">//构造函数初始化shared_ptr      </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>                                <span class="comment">//输出shared_ptr的引用计数和指向的值      </span></span><br><span class="line">	</span>&#123;          <span class="built_in">cout</span> &lt;&lt; <span class="string">"count:"</span> &lt;&lt; p.use_count()              </span><br><span class="line">	&lt;&lt; <span class="string">"v ="</span> &lt;&lt;*p &lt;&lt; endl;      </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_func</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p)</span>				<span class="comment">//使用shared_ptr作为函数参数  </span></span><br><span class="line"></span>&#123;       </span><br><span class="line">	<span class="comment">//同样输出shared_ptr的引用计数和指向的值      </span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"count:"</span> &lt;&lt; p.use_count()          </span><br><span class="line">		&lt;&lt; <span class="string">" v="</span> &lt;&lt;*p &lt;&lt; endl;  &#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;      </span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>));      </span><br><span class="line">	<span class="function">shared <span class="title">s1</span><span class="params">(p)</span>, <span class="title">s2</span><span class="params">(p)</span></span>;                        <span class="comment">//构造两个自定义类       </span></span><br><span class="line">	s1.print();      </span><br><span class="line">	s2.print();       </span><br><span class="line">	*p = <span class="number">20</span>;                                    <span class="comment">//修改shared_ptr所指的值      </span></span><br><span class="line">	print_func(p);      </span><br><span class="line">	s1.print();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用于标准容器">应用于标准容器</h2><p>有两种方式可以将shared_ptr应用于标准容器（或者容器适配器等其他容器）。</p>
<p>一种用法是将容器作为shared_ptr管理的对象，如shared_ptr<list<t> &gt;，使容器可以被安全地共享，用法与普通shared_ptr没有区别，我们不再讨论。</list<t></p>
<p>另一种用法是将shared_ptr作为容器的元素，如vector<shared_ptr<t> &gt;，因为shared_ptr支持拷贝语义和比较操作，符合标准容器对元素的要求，所以可以实现在容器中安全地容纳元素的指针而不是拷贝。</shared_ptr<t></p>
<p>标准容器不能容纳auto_ptr，这是C++标准特别规定的（读者永远也不要有这种想法）。标准容器也不能容纳scoped_ptr，因为scoped_ptr不能拷贝和赋值。标准容器可以容纳原始指针，但这就丧失了容器的许多好处，因为标准容器无法自动管理类型为指针的元素，必须编写额外的大量代码来保证指针最终被正确删除，这通常很麻烦很难实现。</p>
<p>存储shared_ptr的容器与存储原始指针的容器功能几乎一样，但shared_ptr为程序员做了指针的管理工作，可以任意使用shared_ptr而不用担心资源泄漏。</p>
<p>下面的代码示范了将shared_ptr应用于标准容器的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;boost/make_shared.hpp&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;      </span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; vs;    <span class="comment">//一个持有shared_ptr的标准容器类型      </span></span><br><span class="line">	<span class="function">vs <span class="title">v</span><span class="params">(10)</span></span>;                               <span class="comment">//声明一个拥有10个元素的容器，元素被初始化为空指针       </span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;      </span><br><span class="line">	<span class="keyword">for</span> (vs::iterator pos = v.begin(); pos != v.end(); ++pos)      </span><br><span class="line">	&#123;          </span><br><span class="line">		(*pos) = make_shared&lt;<span class="keyword">int</span>&gt;(++i);     <span class="comment">//使用工厂函数赋值          </span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *(*pos) &lt;&lt; <span class="string">", "</span>;            <span class="comment">//输出值      </span></span><br><span class="line">	&#125;      </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;       </span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p = v[<span class="number">9</span>];      </span><br><span class="line">	*p = <span class="number">100</span>;      </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *v[<span class="number">9</span>] &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码需要注意的是迭代器和operator[]的用法，因为容器内存储的是shared_ptr，我们必须对迭代器pos使用一次解引用操作符*以获得shared_ptr，然后再对shared_ptr使用解引用操作符*才能操作真正的值。*(*pos)也可以直接写成**pos，但前者更清晰，后者很容易让人迷惑。vector的operator[]用法与迭代器类似，也需要使用*获取真正的值。</p>
</blockquote>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/05/cpp/pair与make_pair/">
                C++ std::pair 与 std::make_pair
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2014-09-05
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/cpp/">cpp</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/09/05/cpp/pair与make_pair/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/05/cpp/pair与make_pair/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="C++_std::pair_与_std::make_pair">C++ std::pair 与 std::make_pair</h1><ul>
<li>std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。例如std::pair<int,float> 或者 std：：pair<double,double>等。pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：</double,double></int,float></li>
</ul>
<p><code>template pair make_pair(T1 a, T2 b) { return pair(a, b); }</code></p>
<ul>
<li>一般make_pair都使用在需要pair做参数的位置，可以直接调用make_pair生成pair对象。 另一个使用的方面就是pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题：例如有如下两个定义：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">std</span>:<span class="value">:pair&lt;int, float&gt;(<span class="number">1</span>, <span class="number">1.1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="rule"><span class="attribute">std</span>:<span class="value">:<span class="function">make_pair</span>(<span class="number">1</span>, <span class="number">1.1</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中第一个的second变量是float类型，而make_pair函数会将second变量都转换成double类型。这个问题在编程是需要引起注意。下面是一段pair与make_pair的例子程序： </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;utility&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  pair &lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product1 (<span class="string">"tomatoes"</span>,<span class="number">3.25</span>);</span><br><span class="line">  pair &lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product2;</span><br><span class="line">  pair &lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product3;</span><br><span class="line">  product2.first = <span class="string">"lightbulbs"</span>;     <span class="comment">// type of first is string</span></span><br><span class="line">  product2.second = <span class="number">0.99</span>;            <span class="comment">// type of second is double</span></span><br><span class="line">  product3 = make_pair (<span class="string">"shoes"</span>,<span class="number">20.0</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product1.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product1.second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product2.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product2.second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product3.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product3.second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">其运行结果如下：</span><br><span class="line"><span class="number">1</span> The price of tomatoes is $<span class="number">3.25</span></span><br><span class="line"><span class="number">2</span> The price of lightbulbs is $<span class="number">0.99</span></span><br><span class="line"><span class="number">3</span> The price of shoes is $<span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为了更好的了解pair与make_pair的机制，下面是其定义：</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class _Ty1,class _Ty2&gt; struct pair</span><br><span class="line">&#123;   // store a pair <span class="keyword">of</span> values</span><br><span class="line">    typedef pair&lt;_Ty1, _Ty2&gt; _Myt;</span><br><span class="line">    typedef _Ty1 first_type;</span><br><span class="line">    typedef _Ty2 second_type;</span><br><span class="line"></span><br><span class="line">    pair(): first(_Ty1()), second(_Ty2())</span><br><span class="line">        &#123;    // construct <span class="keyword">from</span> defaults</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    pair(<span class="keyword">const</span> _Ty1&amp; _Val1, <span class="keyword">const</span> _Ty2&amp; _Val2): first(_Val1), second(_Val2)</span><br><span class="line">        &#123;    // construct <span class="keyword">from</span> specified values</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;class _Other1,</span><br><span class="line">        class _Other2&gt;</span><br><span class="line">        pair(<span class="keyword">const</span> pair&lt;_Other1, _Other2&gt;&amp; _Right)</span><br><span class="line">        : first(_Right.first), second(_Right.second)</span><br><span class="line">        &#123;    // construct <span class="keyword">from</span> compatible pair</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> swap(_Myt&amp; _Right)</span><br><span class="line">        &#123;    // exchange contents <span class="keyword">with</span> _Right</span><br><span class="line">        std::swap(first, _Right.first);</span><br><span class="line">        std::swap(second, _Right.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    _Ty1 first;    // the first stored value</span><br><span class="line">    _Ty2 second;    // the second stored value</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class _Ty1,class _Ty2&gt; inline</span><br><span class="line">    pair&lt;_Ty1, _Ty2&gt; make_pair(_Ty1 _Val1, _Ty2 _Val2)</span><br><span class="line">    &#123;    // <span class="keyword">return</span> pair composed <span class="keyword">from</span> arguments</span><br><span class="line">    <span class="keyword">return</span> (pair&lt;_Ty1, _Ty2&gt;(_Val1, _Val2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="zhulei" />
          <p class="site-author-name">zhulei</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">77</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">52</span>
              <span class="site-state-item-name">標籤</span>
              
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/zl8522115" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://twitter.com/zl8522115" target="_blank">Twitter</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/zlsky" target="_blank">Weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/zhu-lei-46-87" target="_blank">ZhiHu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2012 - 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">zhulei</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"threestone"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

</body>
</html>
